(self["webpackChunksas_miniappdemo"] = self["webpackChunksas_miniappdemo"] || []).push([["vendors-node_modules_react-navigation_native_src_index_tsx"], {
91059: (function (__unused_webpack_module, exports) {
"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a) {
    if ("object" === typeof a && null !== a) {
        var u = a.$$typeof;
        switch(u){
            case c:
                switch(a = a.type, a){
                    case l:
                    case m:
                    case e:
                    case g:
                    case f:
                    case p:
                        return a;
                    default:
                        switch(a = a && a.$$typeof, a){
                            case k:
                            case n:
                            case t:
                            case r:
                            case h:
                                return a;
                            default:
                                return u;
                        }
                }
            case d:
                return u;
        }
    }
}
function A(a) {
    return z(a) === m;
}
exports.AsyncMode = l;
exports.ConcurrentMode = m;
exports.ContextConsumer = k;
exports.ContextProvider = h;
exports.Element = c;
exports.ForwardRef = n;
exports.Fragment = e;
exports.Lazy = t;
exports.Memo = r;
exports.Portal = d;
exports.Profiler = g;
exports.StrictMode = f;
exports.Suspense = p;
exports.isAsyncMode = function(a) {
    return A(a) || z(a) === l;
};
exports.isConcurrentMode = A;
exports.isContextConsumer = function(a) {
    return z(a) === k;
};
exports.isContextProvider = function(a) {
    return z(a) === h;
};
exports.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
};
exports.isForwardRef = function(a) {
    return z(a) === n;
};
exports.isFragment = function(a) {
    return z(a) === e;
};
exports.isLazy = function(a) {
    return z(a) === t;
};
exports.isMemo = function(a) {
    return z(a) === r;
};
exports.isPortal = function(a) {
    return z(a) === d;
};
exports.isProfiler = function(a) {
    return z(a) === g;
};
exports.isStrictMode = function(a) {
    return z(a) === f;
};
exports.isSuspense = function(a) {
    return z(a) === p;
};
exports.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};
exports.typeOf = z;


}),
12962: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";

if (true) {
    module.exports = __webpack_require__(91059);
} else {}


}),
97427: (function (__unused_webpack_module, exports) {
"use strict";

function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;


}),
13919: (function (__unused_webpack_module, exports) {
"use strict";

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
exports._ = _object_spread_props;


}),
67334: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _object_without_properties_loose = __webpack_require__(69359);
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose._(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
exports._ = _object_without_properties;


}),
69359: (function (__unused_webpack_module, exports) {
"use strict";

function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
exports._ = _object_without_properties_loose;


}),
12323: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _type_of = __webpack_require__(28611);
function _to_primitive(input, hint) {
    if (_type_of._(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_type_of._(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
exports._ = _to_primitive;


}),
28102: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _to_primitive = __webpack_require__(12323);
var _type_of = __webpack_require__(28611);
function _to_property_key(arg) {
    var key = _to_primitive._(arg, "string");
    return _type_of._(key) === "symbol" ? key : String(key);
}
exports._ = _to_property_key;


}),
4578: (function (module) {
"use strict";

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');
function decodeComponents(components, split) {
    try {
        // Try to decode the entire string first
        return [
            decodeURIComponent(components.join(''))
        ];
    } catch (err) {
    // Do nothing
    }
    if (components.length === 1) {
        return components;
    }
    split = split || 1;
    // Split the array in 2 parts
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
    try {
        return decodeURIComponent(input);
    } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for(var i = 1; i < tokens.length; i++){
            input = decodeComponents(tokens, i).join('');
            tokens = input.match(singleMatcher) || [];
        }
        return input;
    }
}
function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
        '%FE%FF': '\uFFFD\uFFFD',
        '%FF%FE': '\uFFFD\uFFFD'
    };
    var match = multiMatcher.exec(input);
    while(match){
        try {
            // Decode as big chunks as possible
            replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
            var result = decode(match[0]);
            if (result !== match[0]) {
                replaceMap[match[0]] = result;
            }
        }
        match = multiMatcher.exec(input);
    }
    // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    replaceMap['%C2'] = '\uFFFD';
    var entries = Object.keys(replaceMap);
    for(var i = 0; i < entries.length; i++){
        // Replace all decoded components
        var key = entries[i];
        input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }
    return input;
}
module.exports = function(encodedURI) {
    if (typeof encodedURI !== 'string') {
        throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }
    try {
        encodedURI = encodedURI.replace(/\+/g, ' ');
        // Try the built in decoder first
        return decodeURIComponent(encodedURI);
    } catch (err) {
        // Fallback to a more advanced decoder
        return customDecodeURIComponent(encodedURI);
    }
};


}),
87695: (function (module) {
"use strict";

module.exports = (string)=>{
    if (typeof string !== 'string') {
        throw new TypeError('Expected a string');
    }
    // Escape characters with special meaning either inside or outside character sets.
    // Use a simple backslash escape when it’s always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
    return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
};


}),
19900: (function (module) {
"use strict";

module.exports = function(obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
            ret[key] = val;
        }
    }
    return ret;
};


}),
15771: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get customAlphabet () {
        return customAlphabet;
    },
    get nanoid () {
        return nanoid;
    }
});
var urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
var customAlphabet = (alphabet, ref)=>{
    var defaultSize = ref === void 0 ? 21 : ref;
    return (ref)=>{
        var size = ref === void 0 ? defaultSize : ref;
        var id = '';
        var i = size | 0;
        while(i--){
            id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
    };
};
var nanoid = (ref)=>{
    var size = ref === void 0 ? 21 : ref;
    var id = '';
    var i = size | 0;
    while(i--){
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};


}),
67198: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(30067);
var _to_consumable_array = __webpack_require__(60116);
var strictUriEncode = __webpack_require__(64155);
var decodeComponent = __webpack_require__(4578);
var splitOnFirst = __webpack_require__(24948);
var filterObject = __webpack_require__(19900);
var isNullOrUndefined = (value)=>value === null || value === undefined;
var encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');
function encoderForArrayFormat(options) {
    switch(options.arrayFormat){
        case 'index':
            return (key)=>(result, value)=>{
                    var index = result.length;
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            [
                                encode(key, options),
                                '[',
                                index,
                                ']'
                            ].join('')
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            '[',
                            encode(index, options),
                            ']=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
        case 'bracket':
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            [
                                encode(key, options),
                                '[]'
                            ].join('')
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            '[]=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
        case 'colon-list-separator':
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            [
                                encode(key, options),
                                ':list='
                            ].join('')
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            ':list=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
        case 'comma':
        case 'separator':
        case 'bracket-separator':
            {
                var keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
                return (key)=>(result, value)=>{
                        if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                            return result;
                        }
                        // Translate null to an empty string so that it doesn't serialize as 'null'
                        value = value === null ? '' : value;
                        if (result.length === 0) {
                            return [
                                [
                                    encode(key, options),
                                    keyValueSep,
                                    encode(value, options)
                                ].join('')
                            ];
                        }
                        return [
                            [
                                result,
                                encode(value, options)
                            ].join(options.arrayFormatSeparator)
                        ];
                    };
            }
        default:
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            encode(key, options)
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            '=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
    }
}
function parserForArrayFormat(options) {
    var result;
    switch(options.arrayFormat){
        case 'index':
            return (key, value, accumulator)=>{
                result = /\[(\d*)\]$/.exec(key);
                key = key.replace(/\[\d*\]$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = {};
                }
                accumulator[key][result[1]] = value;
            };
        case 'bracket':
            return (key, value, accumulator)=>{
                result = /(\[\])$/.exec(key);
                key = key.replace(/\[\]$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = [
                        value
                    ];
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
        case 'colon-list-separator':
            return (key, value, accumulator)=>{
                result = /(:list)$/.exec(key);
                key = key.replace(/:list$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = [
                        value
                    ];
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
        case 'comma':
        case 'separator':
            return (key, value, accumulator)=>{
                var isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
                var isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
                value = isEncodedArray ? decode(value, options) : value;
                var newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item)=>decode(item, options)) : value === null ? value : decode(value, options);
                accumulator[key] = newValue;
            };
        case 'bracket-separator':
            return (key, value, accumulator)=>{
                var isArray = /(\[\])$/.test(key);
                key = key.replace(/\[\]$/, '');
                if (!isArray) {
                    accumulator[key] = value ? decode(value, options) : value;
                    return;
                }
                var arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item)=>decode(item, options));
                if (accumulator[key] === undefined) {
                    accumulator[key] = arrayValue;
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], arrayValue);
            };
        default:
            return (key, value, accumulator)=>{
                if (accumulator[key] === undefined) {
                    accumulator[key] = value;
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
    }
}
function validateArrayFormatSeparator(value) {
    if (typeof value !== 'string' || value.length !== 1) {
        throw new TypeError('arrayFormatSeparator must be single character string');
    }
}
function encode(value, options) {
    if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    }
    return value;
}
function decode(value, options) {
    if (options.decode) {
        return decodeComponent(value);
    }
    return value;
}
function keysSorter(input) {
    if (Array.isArray(input)) {
        return input.sort();
    }
    if (typeof input === 'object') {
        return keysSorter(Object.keys(input)).sort((a, b)=>Number(a) - Number(b)).map((key)=>input[key]);
    }
    return input;
}
function removeHash(input) {
    var hashStart = input.indexOf('#');
    if (hashStart !== -1) {
        input = input.slice(0, hashStart);
    }
    return input;
}
function getHash(url) {
    var hash = '';
    var hashStart = url.indexOf('#');
    if (hashStart !== -1) {
        hash = url.slice(hashStart);
    }
    return hash;
}
function extract(input) {
    input = removeHash(input);
    var queryStart = input.indexOf('?');
    if (queryStart === -1) {
        return '';
    }
    return input.slice(queryStart + 1);
}
function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
        value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
        value = value.toLowerCase() === 'true';
    }
    return value;
}
function parse(query, options) {
    options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ',',
        parseNumbers: false,
        parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    var formatter = parserForArrayFormat(options);
    // Create an object with no prototype
    var ret = Object.create(null);
    if (typeof query !== 'string') {
        return ret;
    }
    query = query.trim().replace(/^[?#&]/, '');
    if (!query) {
        return ret;
    }
    for (var param of query.split('&')){
        if (param === '') {
            continue;
        }
        var _splitOnFirst = _sliced_to_array._(splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '='), 2), key = _splitOnFirst[0], value = _splitOnFirst[1];
        // Missing `=` should be `null`:
        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
        value = value === undefined ? null : [
            'comma',
            'separator',
            'bracket-separator'
        ].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
    }
    for (var key1 of Object.keys(ret)){
        var value1 = ret[key1];
        if (typeof value1 === 'object' && value1 !== null) {
            for (var k of Object.keys(value1)){
                value1[k] = parseValue(value1[k], options);
            }
        } else {
            ret[key1] = parseValue(value1, options);
        }
    }
    if (options.sort === false) {
        return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key)=>{
        var value = ret[key];
        if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
            // Sort object keys, not values
            result[key] = keysSorter(value);
        } else {
            result[key] = value;
        }
        return result;
    }, Object.create(null));
}
exports.extract = extract;
exports.parse = parse;
exports.stringify = (object, options)=>{
    if (!object) {
        return '';
    }
    options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ','
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    var shouldFilter = (key)=>options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
    var formatter = encoderForArrayFormat(options);
    var objectCopy = {};
    for (var key of Object.keys(object)){
        if (!shouldFilter(key)) {
            objectCopy[key] = object[key];
        }
    }
    var keys = Object.keys(objectCopy);
    if (options.sort !== false) {
        keys.sort(options.sort);
    }
    return keys.map((key)=>{
        var value = object[key];
        if (value === undefined) {
            return '';
        }
        if (value === null) {
            return encode(key, options);
        }
        if (Array.isArray(value)) {
            if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
                return encode(key, options) + '[]';
            }
            return value.reduce(formatter(key), []).join('&');
        }
        return encode(key, options) + '=' + encode(value, options);
    }).filter((x)=>x.length > 0).join('&');
};
exports.parseUrl = (url, options)=>{
    options = Object.assign({
        decode: true
    }, options);
    var _splitOnFirst = _sliced_to_array._(splitOnFirst(url, '#'), 2), url_ = _splitOnFirst[0], hash = _splitOnFirst[1];
    return Object.assign({
        url: url_.split('?')[0] || '',
        query: parse(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash ? {
        fragmentIdentifier: decode(hash, options)
    } : {});
};
exports.stringifyUrl = (object, options)=>{
    options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
    }, options);
    var url = removeHash(object.url).split('?')[0] || '';
    var queryFromUrl = exports.extract(object.url);
    var parsedQueryFromUrl = exports.parse(queryFromUrl, {
        sort: false
    });
    var query = Object.assign(parsedQueryFromUrl, object.query);
    var queryString = exports.stringify(query, options);
    if (queryString) {
        queryString = `?${queryString}`;
    }
    var hash = getHash(object.url);
    if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString}${hash}`;
};
exports.pick = (input, filter, options)=>{
    options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
    }, options);
    var _exports_parseUrl = exports.parseUrl(input, options), url = _exports_parseUrl.url, query = _exports_parseUrl.query, fragmentIdentifier = _exports_parseUrl.fragmentIdentifier;
    return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
    }, options);
};
exports.exclude = (input, filter, options)=>{
    var exclusionFilter = Array.isArray(filter) ? (key)=>!filter.includes(key) : (key, value)=>!filter(key, value);
    return exports.pick(input, exclusionFilter, options);
};


}),
24948: (function (module) {
"use strict";

module.exports = (string, separator)=>{
    if (!(typeof string === 'string' && typeof separator === 'string')) {
        throw new TypeError('Expected the arguments to be of type `string`');
    }
    if (separator === '') {
        return [
            string
        ];
    }
    var separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
        return [
            string
        ];
    }
    return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
    ];
};


}),
64155: (function (module) {
"use strict";

module.exports = (str)=>encodeURIComponent(str).replace(/[!'()*]/g, (x)=>`%${x.charCodeAt(0).toString(16).toUpperCase()}`);


}),
85391: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";

var React = __webpack_require__(13668);
var useIsomorphicLayoutEffect_1 = __webpack_require__(68198);
/**
 * React hook which returns the latest callback without changing the reference.
 */ // eslint-disable-next-line @typescript-eslint/ban-types
function useLatestCallback(callback) {
    var ref = React.useRef(callback);
    var latestCallback = React.useRef(function latestCallback() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return ref.current.apply(this, args);
    }).current;
    (0, useIsomorphicLayoutEffect_1.default)(function() {
        ref.current = callback;
    });
    return latestCallback;
}
module.exports = useLatestCallback;


}),
68198: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var react_1 = __webpack_require__(13668);
exports["default"] = react_1.useLayoutEffect;


}),
5348: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _object_without_properties = __webpack_require__(67334);
var _sliced_to_array = __webpack_require__(30067);
var _to_consumable_array = __webpack_require__(60116);
var _jsxruntime = __webpack_require__(53083);
var _routers = __webpack_require__(76951);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _checkDuplicateRouteNames = /*#__PURE__*/ _interop_require_default._(__webpack_require__(51145));
var _checkSerializable = /*#__PURE__*/ _interop_require_default._(__webpack_require__(28721));
var _createNavigationContainerRef = __webpack_require__(409);
var _EnsureSingleNavigator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(86963));
var _findFocusedRoute = /*#__PURE__*/ _interop_require_default._(__webpack_require__(39700));
var _NavigationBuilderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69489));
var _NavigationContainerRefContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(61338));
var _NavigationContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(67423));
var _NavigationRouteContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98405));
var _NavigationStateContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(83203));
var _UnhandledActionContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(11366));
var _useChildListeners = /*#__PURE__*/ _interop_require_default._(__webpack_require__(74964));
var _useEventEmitter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27029));
var _useKeyedChildListeners = /*#__PURE__*/ _interop_require_default._(__webpack_require__(49608));
var _useOptionsGetters = /*#__PURE__*/ _interop_require_default._(__webpack_require__(19645));
var _useScheduleUpdate = __webpack_require__(47392);
var _useSyncState = /*#__PURE__*/ _interop_require_default._(__webpack_require__(66614));
var serializableWarnings = (/* unused pure expression or super */ null && ([]));
var duplicateNameWarnings = (/* unused pure expression or super */ null && ([]));
/**
 * Remove `key` and `routeNames` from the state objects recursively to get partial state.
 *
 * @param state Initial state object.
 */ var getPartialState = (state)=>{
    if (state === undefined) {
        return;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var key = state.key, routeNames = state.routeNames, partialState = _object_without_properties._(state, [
        "key",
        "routeNames"
    ]);
    return _object_spread_props._(_object_spread._({}, partialState), {
        stale: true,
        routes: state.routes.map((route)=>{
            if (route.state === undefined) {
                return route;
            }
            return _object_spread_props._(_object_spread._({}, route), {
                state: getPartialState(route.state)
            });
        })
    });
};
/**
 * Container component which holds the navigation state.
 * This should be rendered at the root wrapping the whole app.
 *
 * @param props.initialState Initial state object for the navigation tree.
 * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
 * @param props.children Child elements to render the content.
 * @param props.ref Ref object which refers to the navigation object containing helper methods.
 */ var BaseNavigationContainer = /*#__PURE__*/ _react.forwardRef(function BaseNavigationContainer(ref, ref1) {
    var initialState = ref.initialState, onStateChange = ref.onStateChange, onUnhandledAction = ref.onUnhandledAction, independent = ref.independent, children = ref.children;
    var parent = _react.useContext(_NavigationStateContext.default);
    if (!parent.isDefault && !independent) {
        throw new Error("Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, pass 'independent={true}' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.");
    }
    var _useSyncState1 = _sliced_to_array._((0, _useSyncState.default)(()=>getPartialState(initialState == null ? undefined : initialState)), 5), state = _useSyncState1[0], getState = _useSyncState1[1], setState = _useSyncState1[2], scheduleUpdate = _useSyncState1[3], flushUpdates = _useSyncState1[4];
    var isFirstMountRef = _react.useRef(true);
    var navigatorKeyRef = _react.useRef();
    var getKey = _react.useCallback(()=>navigatorKeyRef.current, []);
    var setKey = _react.useCallback((key)=>{
        navigatorKeyRef.current = key;
    }, []);
    var _useChildListeners1 = (0, _useChildListeners.default)(), listeners = _useChildListeners1.listeners, addListener = _useChildListeners1.addListener;
    var _useKeyedChildListeners1 = (0, _useKeyedChildListeners.default)(), keyedListeners = _useKeyedChildListeners1.keyedListeners, addKeyedListener = _useKeyedChildListeners1.addKeyedListener;
    var dispatch = _react.useCallback((action)=>{
        if (listeners.focus[0] == null) {
            console.error(_createNavigationContainerRef.NOT_INITIALIZED_ERROR);
        } else {
            listeners.focus[0]((navigation)=>navigation.dispatch(action));
        }
    }, [
        listeners.focus
    ]);
    var canGoBack = _react.useCallback(()=>{
        if (listeners.focus[0] == null) {
            return false;
        }
        var _listeners_focus_ = listeners.focus[0]((navigation)=>navigation.canGoBack()), result = _listeners_focus_.result, handled = _listeners_focus_.handled;
        if (handled) {
            return result;
        } else {
            return false;
        }
    }, [
        listeners.focus
    ]);
    var resetRoot = _react.useCallback((state)=>{
        var _keyedListeners_getState_root, _keyedListeners_getState;
        var target = (state === null || state === void 0 ? void 0 : state.key) ?? ((_keyedListeners_getState_root = (_keyedListeners_getState = keyedListeners.getState).root) === null || _keyedListeners_getState_root === void 0 ? void 0 : _keyedListeners_getState_root.call(_keyedListeners_getState).key);
        if (target == null) {
            console.error(_createNavigationContainerRef.NOT_INITIALIZED_ERROR);
        } else {
            listeners.focus[0]((navigation)=>navigation.dispatch(_object_spread_props._(_object_spread._({}, _routers.CommonActions.reset(state)), {
                    target
                })));
        }
    }, [
        keyedListeners.getState,
        listeners.focus
    ]);
    var getRootState = _react.useCallback(()=>{
        var _keyedListeners_getState_root, _keyedListeners_getState;
        return (_keyedListeners_getState_root = (_keyedListeners_getState = keyedListeners.getState).root) === null || _keyedListeners_getState_root === void 0 ? void 0 : _keyedListeners_getState_root.call(_keyedListeners_getState);
    }, [
        keyedListeners.getState
    ]);
    var getCurrentRoute = _react.useCallback(()=>{
        var state = getRootState();
        if (state == null) {
            return undefined;
        }
        var route = (0, _findFocusedRoute.default)(state);
        return route;
    }, [
        getRootState
    ]);
    var emitter = (0, _useEventEmitter.default)();
    var _useOptionsGetters1 = (0, _useOptionsGetters.default)({}), addOptionsGetter = _useOptionsGetters1.addOptionsGetter, getCurrentOptions = _useOptionsGetters1.getCurrentOptions;
    var navigation = _react.useMemo(()=>_object_spread_props._(_object_spread._({}, Object.keys(_routers.CommonActions).reduce((acc, name)=>{
            var _CommonActions;
            acc[name] = (...args)=>// @ts-expect-error: this is ok
                dispatch((_CommonActions = _routers.CommonActions)[name].apply(_CommonActions, _to_consumable_array._(args)));
            return acc;
        }, {}), emitter.create('root')), {
            dispatch,
            resetRoot,
            isFocused: ()=>true,
            canGoBack,
            getParent: ()=>undefined,
            getState: ()=>stateRef.current,
            getRootState,
            getCurrentRoute,
            getCurrentOptions,
            isReady: ()=>listeners.focus[0] != null,
            setOptions: ()=>{
                throw new Error('Cannot call setOptions outside a screen');
            }
        }), [
        canGoBack,
        dispatch,
        emitter,
        getCurrentOptions,
        getCurrentRoute,
        getRootState,
        listeners.focus,
        resetRoot
    ]);
    _react.useImperativeHandle(ref1, ()=>navigation, [
        navigation
    ]);
    var onDispatchAction = _react.useCallback((action, noop)=>{
        emitter.emit({
            type: '__unsafe_action__',
            data: {
                action,
                noop,
                stack: stackRef.current
            }
        });
    }, [
        emitter
    ]);
    var lastEmittedOptionsRef = _react.useRef();
    var onOptionsChange = _react.useCallback((options)=>{
        if (lastEmittedOptionsRef.current === options) {
            return;
        }
        lastEmittedOptionsRef.current = options;
        emitter.emit({
            type: 'options',
            data: {
                options
            }
        });
    }, [
        emitter
    ]);
    var stackRef = _react.useRef();
    var builderContext = _react.useMemo(()=>({
            addListener,
            addKeyedListener,
            onDispatchAction,
            onOptionsChange,
            stackRef
        }), [
        addListener,
        addKeyedListener,
        onDispatchAction,
        onOptionsChange
    ]);
    var scheduleContext = _react.useMemo(()=>({
            scheduleUpdate,
            flushUpdates
        }), [
        scheduleUpdate,
        flushUpdates
    ]);
    var isInitialRef = _react.useRef(true);
    var getIsInitial = _react.useCallback(()=>isInitialRef.current, []);
    var context = _react.useMemo(()=>({
            state,
            getState,
            setState,
            getKey,
            setKey,
            getIsInitial,
            addOptionsGetter
        }), [
        state,
        getState,
        setState,
        getKey,
        setKey,
        getIsInitial,
        addOptionsGetter
    ]);
    var onStateChangeRef = _react.useRef(onStateChange);
    var stateRef = _react.useRef(state);
    _react.useEffect(()=>{
        isInitialRef.current = false;
        onStateChangeRef.current = onStateChange;
        stateRef.current = state;
    });
    _react.useEffect(()=>{
        var hydratedState = getRootState();
        if (false) { var pointer, message, prev, duplicateRouteNamesResult, i, reason, params, message1, path, curr, location, serializableResult }
        emitter.emit({
            type: 'state',
            data: {
                state
            }
        });
        if (!isFirstMountRef.current && onStateChangeRef.current) {
            onStateChangeRef.current(hydratedState);
        }
        isFirstMountRef.current = false;
    }, [
        getRootState,
        emitter,
        state
    ]);
    var defaultOnUnhandledAction = _react.useCallback((action)=>{
        if (true) {
            return;
        }
        var payload = action.payload;
        var message = `The action '${action.type}'${payload ? ` with payload ${JSON.stringify(action.payload)}` : ''} was not handled by any navigator.`;
        switch(action.type){
            case 'NAVIGATE':
            case 'PUSH':
            case 'REPLACE':
            case 'JUMP_TO':
                if (payload === null || payload === void 0 ? void 0 : payload.name) {
                    message += `\n\nDo you have a screen named '${payload.name}'?\n\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.`;
                } else {
                    message += `\n\nYou need to pass the name of the screen to navigate to.\n\nSee https://reactnavigation.org/docs/navigation-actions for usage.`;
                }
                break;
            case 'GO_BACK':
            case 'POP':
            case 'POP_TO_TOP':
                message += `\n\nIs there any screen to go back to?`;
                break;
            case 'OPEN_DRAWER':
            case 'CLOSE_DRAWER':
            case 'TOGGLE_DRAWER':
                message += `\n\nIs your screen inside a Drawer navigator?`;
                break;
        }
        message += `\n\nThis is a development-only warning and won't be shown in production.`;
        console.error(message);
    }, []);
    var element = /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationContainerRefContext.default.Provider, {
        value: navigation,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_useScheduleUpdate.ScheduleUpdateContext.Provider, {
            value: scheduleContext,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationBuilderContext.default.Provider, {
                value: builderContext,
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationStateContext.default.Provider, {
                    value: context,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnhandledActionContext.default.Provider, {
                        value: onUnhandledAction ?? defaultOnUnhandledAction,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_EnsureSingleNavigator.default, {
                            children: children
                        })
                    })
                })
            })
        })
    });
    if (independent) {
        // We need to clear any existing contexts for nested independent container to work correctly
        element = /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationRouteContext.default.Provider, {
            value: undefined,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationContext.default.Provider, {
                value: undefined,
                children: element
            })
        });
    }
    return element;
});
var _default = BaseNavigationContainer;


}),
47023: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
/**
 * Context which holds the values for the current navigation tree.
 * Intended for use in SSR. This is not safe to use on the client.
 */ var CurrentRenderContext = /*#__PURE__*/ _react.createContext(undefined);
var _default = CurrentRenderContext;


}),
86963: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get SingleNavigatorContext () {
        return SingleNavigatorContext;
    },
    get /**
 * Component which ensures that there's only one navigator nested under it.
 */ default () {
        return EnsureSingleNavigator;
    }
});
var _interop_require_wildcard = __webpack_require__(97427);
var _jsxruntime = __webpack_require__(53083);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var MULTIPLE_NAVIGATOR_ERROR = `Another navigator is already registered for this container. You likely have multiple navigators under a single "NavigationContainer" or "Screen". Make sure each navigator is under a separate "Screen" container. See https://reactnavigation.org/docs/nesting-navigators for a guide on nesting.`;
var SingleNavigatorContext = /*#__PURE__*/ _react.createContext(undefined);
function EnsureSingleNavigator(ref) {
    var children = ref.children;
    var navigatorKeyRef = _react.useRef();
    var value = _react.useMemo(()=>({
            register (key) {
                var currentKey = navigatorKeyRef.current;
                if (currentKey !== undefined && key !== currentKey) {
                    throw new Error(MULTIPLE_NAVIGATOR_ERROR);
                }
                navigatorKeyRef.current = key;
            },
            unregister (key) {
                var currentKey = navigatorKeyRef.current;
                if (key !== currentKey) {
                    return;
                }
                navigatorKeyRef.current = undefined;
            }
        }), []);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(SingleNavigatorContext.Provider, {
        value: value,
        children: children
    });
}


}),
45090: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return Group;
    }
}));
function Group(_) {
    /* istanbul ignore next */ return null;
}


}),
69489: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
/**
 * Context which holds the required helpers needed to build nested navigators.
 */ var NavigationBuilderContext = /*#__PURE__*/ _react.createContext({
    onDispatchAction: ()=>undefined,
    onOptionsChange: ()=>undefined
});
var _default = NavigationBuilderContext;


}),
61338: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
/**
 * Context which holds the route prop for a screen.
 */ var NavigationContainerRefContext = /*#__PURE__*/ _react.createContext(undefined);
var _default = NavigationContainerRefContext;


}),
67423: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
/**
 * Context which holds the navigation prop for a screen.
 */ var NavigationContext = /*#__PURE__*/ _react.createContext(undefined);
var _default = NavigationContext;


}),
75388: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
/**
 * Context which holds the navigation helpers of the parent navigator.
 * Navigators should use this context in their view component.
 */ var NavigationHelpersContext = /*#__PURE__*/ _react.createContext(undefined);
var _default = NavigationHelpersContext;


}),
98405: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
/**
 * Context which holds the route prop for a screen.
 */ var NavigationRouteContext = /*#__PURE__*/ _react.createContext(undefined);
var _default = NavigationRouteContext;


}),
83203: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var MISSING_CONTEXT_ERROR = "Couldn't find a navigation context. Have you wrapped your app with 'NavigationContainer'? See https://reactnavigation.org/docs/getting-started for setup instructions.";
var _default = /*#__PURE__*/ _react.createContext({
    isDefault: true,
    get getKey () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setKey () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get getState () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setState () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get getIsInitial () {
        throw new Error(MISSING_CONTEXT_ERROR);
    }
});


}),
24889: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var PreventRemoveContext = /*#__PURE__*/ _react.createContext(undefined);
var _default = PreventRemoveContext;


}),
5102: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return PreventRemoveProvider;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _sliced_to_array = __webpack_require__(30067);
var _to_consumable_array = __webpack_require__(60116);
var _jsxruntime = __webpack_require__(53083);
var _nonsecure = __webpack_require__(15771);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _uselatestcallback = /*#__PURE__*/ _interop_require_default._(__webpack_require__(85391));
var _NavigationHelpersContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(75388));
var _NavigationRouteContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98405));
var _PreventRemoveContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(24889));
/**
 * Util function to transform map of prevented routes to a simpler object.
 */ var transformPreventedRoutes = (preventedRoutesMap)=>{
    var preventedRoutesToTransform = _to_consumable_array._(preventedRoutesMap.values());
    var preventedRoutes = preventedRoutesToTransform.reduce((acc, ref)=>{
        var routeKey = ref.routeKey, preventRemove = ref.preventRemove;
        var _acc_routeKey;
        acc[routeKey] = {
            preventRemove: ((_acc_routeKey = acc[routeKey]) === null || _acc_routeKey === void 0 ? void 0 : _acc_routeKey.preventRemove) || preventRemove
        };
        return acc;
    }, {});
    return preventedRoutes;
};
function PreventRemoveProvider(ref) {
    var children = ref.children;
    var _React_useState = _sliced_to_array._(_react.useState(()=>(0, _nonsecure.nanoid)()), 1), parentId = _React_useState[0];
    var _React_useState1 = _sliced_to_array._(_react.useState(new Map()), 2), preventedRoutesMap = _React_useState1[0], setPreventedRoutesMap = _React_useState1[1];
    var navigation = _react.useContext(_NavigationHelpersContext.default);
    var route = _react.useContext(_NavigationRouteContext.default);
    var preventRemoveContextValue = _react.useContext(_PreventRemoveContext.default);
    // take `setPreventRemove` from parent context - if exist it means we're in a nested context
    var setParentPrevented = preventRemoveContextValue === null || preventRemoveContextValue === void 0 ? void 0 : preventRemoveContextValue.setPreventRemove;
    var setPreventRemove = (0, _uselatestcallback.default)((id, routeKey, preventRemove)=>{
        if (preventRemove && (navigation == null || (navigation === null || navigation === void 0 ? void 0 : navigation.getState().routes.every((route)=>route.key !== routeKey)))) {
            throw new Error(`Couldn't find a route with the key ${routeKey}. Is your component inside NavigationContent?`);
        }
        setPreventedRoutesMap((prevPrevented)=>{
            var _prevPrevented_get, _prevPrevented_get1;
            // values haven't changed - do nothing
            if (routeKey === ((_prevPrevented_get = prevPrevented.get(id)) === null || _prevPrevented_get === void 0 ? void 0 : _prevPrevented_get.routeKey) && preventRemove === ((_prevPrevented_get1 = prevPrevented.get(id)) === null || _prevPrevented_get1 === void 0 ? void 0 : _prevPrevented_get1.preventRemove)) {
                return prevPrevented;
            }
            var nextPrevented = new Map(prevPrevented);
            if (preventRemove) {
                nextPrevented.set(id, {
                    routeKey,
                    preventRemove
                });
            } else {
                nextPrevented.delete(id);
            }
            return nextPrevented;
        });
    });
    var isPrevented = _to_consumable_array._(preventedRoutesMap.values()).some((ref)=>{
        var preventRemove = ref.preventRemove;
        return preventRemove;
    });
    _react.useEffect(()=>{
        if ((route === null || route === void 0 ? void 0 : route.key) !== undefined && setParentPrevented !== undefined) {
            // when route is defined (and setParentPrevented) it means we're in a nested stack
            // route.key then will be the route key of parent
            setParentPrevented(parentId, route.key, isPrevented);
            return ()=>{
                setParentPrevented(parentId, route.key, false);
            };
        }
        return;
    }, [
        parentId,
        isPrevented,
        route === null || route === void 0 ? void 0 : route.key,
        setParentPrevented
    ]);
    var value = _react.useMemo(()=>({
            setPreventRemove,
            preventedRoutes: transformPreventedRoutes(preventedRoutesMap)
        }), [
        setPreventRemove,
        preventedRoutesMap
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_PreventRemoveContext.default.Provider, {
        value: value,
        children: children
    });
}


}),
87803: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return SceneView;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _jsxruntime = __webpack_require__(53083);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _EnsureSingleNavigator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(86963));
var _NavigationStateContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(83203));
var _StaticContainer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69643));
var _useOptionsGetters = /*#__PURE__*/ _interop_require_default._(__webpack_require__(19645));
function SceneView(ref) {
    var screen = ref.screen, route = ref.route, navigation = ref.navigation, routeState = ref.routeState, getState = ref.getState, setState = ref.setState, options = ref.options, clearOptions = ref.clearOptions;
    var navigatorKeyRef = _react.useRef();
    var getKey = _react.useCallback(()=>navigatorKeyRef.current, []);
    var addOptionsGetter = (0, _useOptionsGetters.default)({
        key: route.key,
        options,
        navigation
    }).addOptionsGetter;
    var setKey = _react.useCallback((key)=>{
        navigatorKeyRef.current = key;
    }, []);
    var getCurrentState = _react.useCallback(()=>{
        var state = getState();
        var currentRoute = state.routes.find((r)=>r.key === route.key);
        return currentRoute ? currentRoute.state : undefined;
    }, [
        getState,
        route.key
    ]);
    var setCurrentState = _react.useCallback((child)=>{
        var state = getState();
        setState(_object_spread_props._(_object_spread._({}, state), {
            routes: state.routes.map((r)=>r.key === route.key ? _object_spread_props._(_object_spread._({}, r), {
                    state: child
                }) : r)
        }));
    }, [
        getState,
        route.key,
        setState
    ]);
    var isInitialRef = _react.useRef(true);
    _react.useEffect(()=>{
        isInitialRef.current = false;
    });
    // Clear options set by this screen when it is unmounted
    _react.useEffect(()=>{
        return clearOptions;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var getIsInitial = _react.useCallback(()=>isInitialRef.current, []);
    var context = _react.useMemo(()=>({
            state: routeState,
            getState: getCurrentState,
            setState: setCurrentState,
            getKey,
            setKey,
            getIsInitial,
            addOptionsGetter
        }), [
        routeState,
        getCurrentState,
        setCurrentState,
        getKey,
        setKey,
        getIsInitial,
        addOptionsGetter
    ]);
    var ScreenComponent = screen.getComponent ? screen.getComponent() : screen.component;
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationStateContext.default.Provider, {
        value: context,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_EnsureSingleNavigator.default, {
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_StaticContainer.default, {
                name: screen.name,
                render: ScreenComponent || screen.children,
                navigation: navigation,
                route: route,
                children: ScreenComponent !== undefined ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ScreenComponent, {
                    navigation: navigation,
                    route: route
                }) : screen.children !== undefined ? screen.children({
                    navigation,
                    route
                }) : null
            })
        })
    });
}


}),
83525: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return Screen;
    }
}));
function Screen(_) {
    /* istanbul ignore next */ return null;
}


}),
69643: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
/**
 * Component which prevents updates for children if no props changed
 */ function StaticContainer(props) {
    return props.children;
}
var _default = /*#__PURE__*/ _react.memo(StaticContainer, (prevProps, nextProps)=>{
    var prevPropKeys = Object.keys(prevProps);
    var nextPropKeys = Object.keys(nextProps);
    if (prevPropKeys.length !== nextPropKeys.length) {
        return false;
    }
    for (var key of prevPropKeys){
        if (key === 'children') {
            continue;
        }
        if (prevProps[key] !== nextProps[key]) {
            return false;
        }
    }
    return true;
});


}),
11366: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var UnhandledActionContext = /*#__PURE__*/ _react.createContext(undefined);
var _default = UnhandledActionContext;


}),
51145: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return checkDuplicateRouteNames;
    }
}));
function checkDuplicateRouteNames(state) {
    var duplicates = [];
    var getRouteNames = (location, state)=>{
        state.routes.forEach((route)=>{
            var _route_state_routeNames, _route_state;
            var currentLocation = location ? `${location} > ${route.name}` : route.name;
            (_route_state = route.state) === null || _route_state === void 0 ? void 0 : (_route_state_routeNames = _route_state.routeNames) === null || _route_state_routeNames === void 0 ? void 0 : _route_state_routeNames.forEach((routeName)=>{
                if (routeName === route.name) {
                    duplicates.push([
                        currentLocation,
                        `${currentLocation} > ${route.name}`
                    ]);
                }
            });
            if (route.state) {
                getRouteNames(currentLocation, route.state);
            }
        });
    };
    getRouteNames('', state);
    return duplicates;
}


}),
28721: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return checkSerializable;
    }
}));
var _to_consumable_array = __webpack_require__(60116);
var checkSerializableWithoutCircularReference = (o, seen, location)=>{
    if (o === undefined || o === null || typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string') {
        return {
            serializable: true
        };
    }
    if (Object.prototype.toString.call(o) !== '[object Object]' && !Array.isArray(o)) {
        return {
            serializable: false,
            location,
            reason: typeof o === 'function' ? 'Function' : String(o)
        };
    }
    if (seen.has(o)) {
        return {
            serializable: false,
            reason: 'Circular reference',
            location
        };
    }
    seen.add(o);
    if (Array.isArray(o)) {
        for(var i = 0; i < o.length; i++){
            var childResult = checkSerializableWithoutCircularReference(o[i], new Set(seen), _to_consumable_array._(location).concat([
                i
            ]));
            if (!childResult.serializable) {
                return childResult;
            }
        }
    } else {
        for(var key in o){
            var childResult1 = checkSerializableWithoutCircularReference(o[key], new Set(seen), _to_consumable_array._(location).concat([
                key
            ]));
            if (!childResult1.serializable) {
                return childResult1;
            }
        }
    }
    return {
        serializable: true
    };
};
function checkSerializable(o) {
    return checkSerializableWithoutCircularReference(o, new Set(), []);
}


}),
409: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get NOT_INITIALIZED_ERROR () {
        return NOT_INITIALIZED_ERROR;
    },
    get default () {
        return createNavigationContainerRef;
    }
});
var _object_spread = __webpack_require__(40556);
var _sliced_to_array = __webpack_require__(30067);
var _to_consumable_array = __webpack_require__(60116);
var _routers = __webpack_require__(76951);
var NOT_INITIALIZED_ERROR = "The 'navigation' object hasn't been initialized yet. This might happen if you don't have a navigator mounted, or if the navigator hasn't finished mounting. See https://reactnavigation.org/docs/navigating-without-navigation-prop#handling-initialization for more details.";
function createNavigationContainerRef() {
    var methods = _to_consumable_array._(Object.keys(_routers.CommonActions)).concat([
        'addListener',
        'removeListener',
        'resetRoot',
        'dispatch',
        'isFocused',
        'canGoBack',
        'getRootState',
        'getState',
        'getParent',
        'getCurrentRoute',
        'getCurrentOptions'
    ]);
    var listeners = {};
    var removeListener = (event, callback)=>{
        if (listeners[event]) {
            listeners[event] = listeners[event].filter((cb)=>cb !== callback);
        }
    };
    var current = null;
    var ref = _object_spread._({
        get current () {
            return current;
        },
        set current (value){
            current = value;
            if (value != null) {
                Object.entries(listeners).forEach((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), event = _ref[0], callbacks = _ref[1];
                    callbacks.forEach((callback)=>{
                        value.addListener(event, callback);
                    });
                });
            }
        },
        isReady: ()=>{
            if (current == null) {
                return false;
            }
            return current.isReady();
        }
    }, methods.reduce((acc, name)=>{
        acc[name] = (...args)=>{
            if (current == null) {
                switch(name){
                    case 'addListener':
                        {
                            var _args = _sliced_to_array._(args, 2), event = _args[0], callback = _args[1];
                            listeners[event] = listeners[event] || [];
                            listeners[event].push(callback);
                            return ()=>removeListener(event, callback);
                        }
                    case 'removeListener':
                        {
                            var _args1 = _sliced_to_array._(args, 2), event1 = _args1[0], callback1 = _args1[1];
                            removeListener(event1, callback1);
                            break;
                        }
                    default:
                        console.error(NOT_INITIALIZED_ERROR);
                }
            } else {
                var _current;
                // @ts-expect-error: this is ok
                return (_current = current)[name].apply(_current, _to_consumable_array._(args));
            }
        };
        return acc;
    }, {}));
    return ref;
}


}),
87341: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return createNavigatorFactory;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _Group = /*#__PURE__*/ _interop_require_default._(__webpack_require__(45090));
var _Screen = /*#__PURE__*/ _interop_require_default._(__webpack_require__(83525));
function createNavigatorFactory(Navigator) {
    return function() {
        if (arguments[0] !== undefined) {
            throw new Error("Creating a navigator doesn't take an argument. Maybe you are trying to use React Navigation 4 API? See https://reactnavigation.org/docs/hello-react-navigation for the latest API and guides.");
        }
        return {
            Navigator,
            Group: _Group.default,
            Screen: _Screen.default
        };
    };
}


}),
39700: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return findFocusedRoute;
    }
}));
function findFocusedRoute(state) {
    var current = state;
    while((current === null || current === void 0 ? void 0 : current.routes[current.index ?? 0].state) != null){
        current = current.routes[current.index ?? 0].state;
    }
    var route = current === null || current === void 0 ? void 0 : current.routes[(current === null || current === void 0 ? void 0 : current.index) ?? 0];
    return route;
}


}),
6452: (function (__unused_webpack_module, exports, __webpack_require__) {
// Object.fromEntries is not available in older iOS versions
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return fromEntries;
    }
}));
var _sliced_to_array = __webpack_require__(30067);
function fromEntries(entries) {
    return entries.reduce((acc, ref)=>{
        var _ref = _sliced_to_array._(ref, 2), k = _ref[0], v = _ref[1];
        if (acc.hasOwnProperty(k)) {
            throw new Error(`A value for key '${k}' already exists in the object.`);
        }
        acc[k] = v;
        return acc;
    }, {});
}


}),
10640: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return getActionFromState;
    }
}));
var _object_spread = __webpack_require__(40556);
var _sliced_to_array = __webpack_require__(30067);
function getActionFromState(state, options) {
    var _normalizedConfig_screens;
    // Create a normalized configs object which will be easier to use
    var normalizedConfig = options ? createNormalizedConfigItem(options) : {};
    var routes = state.index != null ? state.routes.slice(0, state.index + 1) : state.routes;
    if (routes.length === 0) {
        return undefined;
    }
    if (!(routes.length === 1 && routes[0].key === undefined || routes.length === 2 && routes[0].key === undefined && routes[0].name === (normalizedConfig === null || normalizedConfig === void 0 ? void 0 : normalizedConfig.initialRouteName) && routes[1].key === undefined)) {
        return {
            type: 'RESET',
            payload: state
        };
    }
    var route = state.routes[state.index ?? state.routes.length - 1];
    var current = route === null || route === void 0 ? void 0 : route.state;
    var config = normalizedConfig === null || normalizedConfig === void 0 ? void 0 : (_normalizedConfig_screens = normalizedConfig.screens) === null || _normalizedConfig_screens === void 0 ? void 0 : _normalizedConfig_screens[route === null || route === void 0 ? void 0 : route.name];
    var params = _object_spread._({}, route.params);
    var payload = route ? {
        name: route.name,
        path: route.path,
        params
    } : undefined;
    while(current){
        var _config_screens;
        if (current.routes.length === 0) {
            return undefined;
        }
        var routes1 = current.index != null ? current.routes.slice(0, current.index + 1) : current.routes;
        var route1 = routes1[routes1.length - 1];
        // Explicitly set to override existing value when merging params
        Object.assign(params, {
            initial: undefined,
            screen: undefined,
            params: undefined,
            state: undefined
        });
        if (routes1.length === 1 && routes1[0].key === undefined) {
            params.initial = true;
            params.screen = route1.name;
        } else if (routes1.length === 2 && routes1[0].key === undefined && routes1[0].name === (config === null || config === void 0 ? void 0 : config.initialRouteName) && routes1[1].key === undefined) {
            params.initial = false;
            params.screen = route1.name;
        } else {
            params.state = current;
            break;
        }
        if (route1.state) {
            params.params = _object_spread._({}, route1.params);
            params = params.params;
        } else {
            params.path = route1.path;
            params.params = route1.params;
        }
        current = route1.state;
        config = config === null || config === void 0 ? void 0 : (_config_screens = config.screens) === null || _config_screens === void 0 ? void 0 : _config_screens[route1.name];
    }
    if (!payload) {
        return;
    }
    // Try to construct payload for a `NAVIGATE` action from the state
    // This lets us preserve the navigation state and not lose it
    return {
        type: 'NAVIGATE',
        payload
    };
}
var createNormalizedConfigItem = (config)=>typeof config === 'object' && config != null ? {
        initialRouteName: config.initialRouteName,
        screens: config.screens != null ? createNormalizedConfigs(config.screens) : undefined
    } : {};
var createNormalizedConfigs = (options)=>Object.entries(options).reduce((acc, ref)=>{
        var _ref = _sliced_to_array._(ref, 2), k = _ref[0], v = _ref[1];
        acc[k] = createNormalizedConfigItem(v);
        return acc;
    }, {});


}),
63695: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return getFocusedRouteNameFromRoute;
    }
}));
var _useRouteCache = __webpack_require__(41207);
function getFocusedRouteNameFromRoute(route) {
    // @ts-expect-error: this isn't in type definitions coz we want this private
    var state = route[_useRouteCache.CHILD_STATE] ?? route.state;
    var params = route.params;
    var routeName = state ? state.routes[// If we have a partial state without index, for tab/drawer, first screen will be focused one, and last for stack
    // The type property will only exist for rehydrated state and not for state from deep link
    state.index ?? (typeof state.type === 'string' && state.type !== 'stack' ? 0 : state.routes.length - 1)].name : typeof (params === null || params === void 0 ? void 0 : params.screen) === 'string' ? params.screen : undefined;
    return routeName;
}


}),
89656: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return getPathFromState;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _sliced_to_array = __webpack_require__(30067);
var _to_consumable_array = __webpack_require__(60116);
var _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(67198));
var _fromEntries = /*#__PURE__*/ _interop_require_default._(__webpack_require__(6452));
var _validatePathConfig = /*#__PURE__*/ _interop_require_default._(__webpack_require__(12853));
var _instance;
var getActiveRoute = (state)=>{
    var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];
    if (route.state) {
        return getActiveRoute(route.state);
    }
    return route;
};
function getPathFromState(state, options) {
    var _loop = function() {
        var _loop = function() {
            pattern = currentOptions[route.name].pattern;
            nestedRouteNames.push(route.name);
            if (route.params) {
                var _currentOptions_route_name;
                var stringify = (_currentOptions_route_name = currentOptions[route.name]) === null || _currentOptions_route_name === void 0 ? void 0 : _currentOptions_route_name.stringify;
                var currentParams = (0, _fromEntries.default)(Object.entries(route.params).map((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                    return [
                        key,
                        (stringify === null || stringify === void 0 ? void 0 : stringify[key]) ? stringify[key](value) : String(value)
                    ];
                }));
                if (pattern) {
                    Object.assign(allParams, currentParams);
                }
                if (focusedRoute === route) {
                    // If this is the focused route, keep the params for later use
                    // We save it here since it's been stringified already
                    focusedParams = _object_spread._({}, currentParams);
                    pattern === null || pattern === void 0 ? void 0 : pattern.split('/').filter((p)=>p.startsWith(':'))// eslint-disable-next-line no-loop-func
                    .forEach((p)=>{
                        var name = getParamName(p);
                        // Remove the params present in the pattern since we'll only use the rest for query string
                        if (focusedParams) {
                            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                            delete focusedParams[name];
                        }
                    });
                }
            }
            // If there is no `screens` property or no nested state, we return pattern
            if (!currentOptions[route.name].screens || route.state === undefined) {
                hasNext = false;
            } else {
                index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;
                var nextRoute = route.state.routes[index];
                var nestedConfig = currentOptions[route.name].screens;
                // if there is config for next route name, we go deeper
                if (nestedConfig && nextRoute.name in nestedConfig) {
                    route = nextRoute;
                    currentOptions = nestedConfig;
                } else {
                    // If not, there is no sense in going deeper in config
                    hasNext = false;
                }
            }
        };
        var index = typeof current.index === 'number' ? current.index : 0;
        var route = current.routes[index];
        var pattern = void 0;
        var focusedParams = void 0;
        var focusedRoute = getActiveRoute(state);
        var currentOptions = configs;
        // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined
        var nestedRouteNames = [];
        var hasNext = true;
        while(route.name in currentOptions && hasNext)_loop();
        if (pattern === undefined) {
            pattern = nestedRouteNames.join('/');
        }
        if (currentOptions[route.name] !== undefined) {
            path += pattern.split('/').map((p)=>{
                var name = getParamName(p);
                // We don't know what to show for wildcard patterns
                // Showing the route name seems ok, though whatever we show here will be incorrect
                // Since the page doesn't actually exist
                if (p === '*') {
                    return route.name;
                }
                // If the path has a pattern for a param, put the param in the path
                if (p.startsWith(':')) {
                    var value = allParams[name];
                    if (value === undefined && p.endsWith('?')) {
                        // Optional params without value assigned in route.params should be ignored
                        return '';
                    }
                    return encodeURIComponent(value);
                }
                return encodeURIComponent(p);
            }).join('/');
        } else {
            path += encodeURIComponent(route.name);
        }
        if (!focusedParams) {
            focusedParams = focusedRoute.params;
        }
        if (route.state) {
            path += '/';
        } else if (focusedParams) {
            for(var param in focusedParams){
                if (focusedParams[param] === 'undefined') {
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete focusedParams[param];
                }
            }
            var query = _querystring.stringify(focusedParams, {
                sort: false
            });
            if (query) {
                path += `?${query}`;
            }
        }
        current = route.state;
    };
    if (state == null) {
        throw Error("Got 'undefined' for the navigation state. You must pass a valid state object.");
    }
    if (options) {
        (0, _validatePathConfig.default)(options);
    }
    // Create a normalized configs object which will be easier to use
    var configs = (options === null || options === void 0 ? void 0 : options.screens) ? createNormalizedConfigs(options === null || options === void 0 ? void 0 : options.screens) : {};
    var path = '/';
    var current = state;
    var allParams = {};
    while(current)_loop();
    // Remove multiple as well as trailing slashes
    path = path.replace(/\/+/g, '/');
    path = path.length > 1 ? path.replace(/\/$/, '') : path;
    return path;
}
var getParamName = (pattern)=>pattern.replace(/^:/, '').replace(/\?$/, '');
var joinPaths = (...paths)=>(_instance = []).concat.apply(_instance, _to_consumable_array._(paths.map((p)=>p.split('/')))).filter(Boolean).join('/');
var createConfigItem = (config, parentPattern)=>{
    if (typeof config === 'string') {
        // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
        var pattern = parentPattern ? joinPaths(parentPattern, config) : config;
        return {
            pattern
        };
    }
    // If an object is specified as the value (e.g. Foo: { ... }),
    // It can have `path` property and `screens` prop which has nested configs
    var pattern1;
    if (config.exact && config.path === undefined) {
        throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
    }
    pattern1 = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';
    var screens = config.screens ? createNormalizedConfigs(config.screens, pattern1) : undefined;
    return {
        // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
        pattern: pattern1 === null || pattern1 === void 0 ? void 0 : pattern1.split('/').filter(Boolean).join('/'),
        stringify: config.stringify,
        screens
    };
};
var createNormalizedConfigs = (options, pattern)=>(0, _fromEntries.default)(Object.entries(options).map((ref)=>{
        var _ref = _sliced_to_array._(ref, 2), name = _ref[0], c = _ref[1];
        var result = createConfigItem(c, pattern);
        return [
            name,
            result
        ];
    }));


}),
37568: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return getStateFromPath;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _to_consumable_array = __webpack_require__(60116);
var _escapestringregexp = /*#__PURE__*/ _interop_require_default._(__webpack_require__(87695));
var _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(67198));
var _findFocusedRoute = /*#__PURE__*/ _interop_require_default._(__webpack_require__(39700));
var _validatePathConfig = /*#__PURE__*/ _interop_require_default._(__webpack_require__(12853));
var _instance;
function getStateFromPath(path, options) {
    var _instance;
    if (options) {
        (0, _validatePathConfig.default)(options);
    }
    var initialRoutes = [];
    if (options === null || options === void 0 ? void 0 : options.initialRouteName) {
        initialRoutes.push({
            initialRouteName: options.initialRouteName,
            parentScreens: []
        });
    }
    var screens = options === null || options === void 0 ? void 0 : options.screens;
    var remaining = path.replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
    .replace(/^\//, '') // Remove extra leading slash
    .replace(/\?.*$/, ''); // Remove query params which we will handle later
    // Make sure there is a trailing slash
    remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;
    if (screens === undefined) {
        // When no config is specified, use the path segments as route names
        var routes = remaining.split('/').filter(Boolean).map((segment)=>{
            var name = decodeURIComponent(segment);
            return {
                name
            };
        });
        if (routes.length) {
            return createNestedStateObject(path, routes, initialRoutes);
        }
        return undefined;
    }
    // Create a normalized configs array which will be easier to use
    var configs = (_instance = []).concat.apply(_instance, _to_consumable_array._(Object.keys(screens).map((key)=>createNormalizedConfigs(key, screens, [], initialRoutes, [])))).sort((a, b)=>{
        // Sort config so that:
        // - the most exhaustive ones are always at the beginning
        // - patterns with wildcard are always at the end
        // If 2 patterns are same, move the one with less route names up
        // This is an error state, so it's only useful for consistent error messages
        if (a.pattern === b.pattern) {
            return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
        }
        // If one of the patterns starts with the other, it's more exhaustive
        // So move it up
        if (a.pattern.startsWith(b.pattern)) {
            return -1;
        }
        if (b.pattern.startsWith(a.pattern)) {
            return 1;
        }
        var aParts = a.pattern.split('/');
        var bParts = b.pattern.split('/');
        for(var i = 0; i < Math.max(aParts.length, bParts.length); i++){
            // if b is longer, b get higher priority
            if (aParts[i] == null) {
                return 1;
            }
            // if a is longer, a get higher priority
            if (bParts[i] == null) {
                return -1;
            }
            var aWildCard = aParts[i] === '*' || aParts[i].startsWith(':');
            var bWildCard = bParts[i] === '*' || bParts[i].startsWith(':');
            // if both are wildcard we compare next component
            if (aWildCard && bWildCard) {
                continue;
            }
            // if only a is wild card, b get higher priority
            if (aWildCard) {
                return 1;
            }
            // if only b is wild card, a get higher priority
            if (bWildCard) {
                return -1;
            }
        }
        return bParts.length - aParts.length;
    });
    // Check for duplicate patterns in the config
    configs.reduce((acc, config)=>{
        if (acc[config.pattern]) {
            var a = acc[config.pattern].routeNames;
            var b = config.routeNames;
            // It's not a problem if the path string omitted from a inner most screen
            // For example, it's ok if a path resolves to `A > B > C` or `A > B`
            var intersects = a.length > b.length ? b.every((it, i)=>a[i] === it) : a.every((it, i)=>b[i] === it);
            if (!intersects) {
                throw new Error(`Found conflicting screens with the same pattern. The pattern '${config.pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);
            }
        }
        return Object.assign(acc, {
            [config.pattern]: config
        });
    }, {});
    if (remaining === '/') {
        // We need to add special handling of empty path so navigation to empty path also works
        // When handling empty path, we should only look at the root level config
        var match = configs.find((config)=>config.path === '' && config.routeNames.every(// Make sure that none of the parent configs have a non-empty path defined
            (name)=>{
                var _configs_find;
                return !((_configs_find = configs.find((c)=>c.screen === name)) === null || _configs_find === void 0 ? void 0 : _configs_find.path);
            }));
        if (match) {
            return createNestedStateObject(path, match.routeNames.map((name)=>({
                    name
                })), initialRoutes, configs);
        }
        return undefined;
    }
    var result;
    var current;
    // We match the whole path against the regex instead of segments
    // This makes sure matches such as wildcard will catch any unmatched routes, even if nested
    var _matchAgainstConfigs = matchAgainstConfigs(remaining, configs.map((c)=>_object_spread_props._(_object_spread._({}, c), {
            // Add `$` to the regex to make sure it matches till end of the path and not just beginning
            regex: c.regex ? new RegExp(c.regex.source + '$') : undefined
        }))), routes1 = _matchAgainstConfigs.routes, remainingPath = _matchAgainstConfigs.remainingPath;
    if (routes1 !== undefined) {
        // This will always be empty if full path matched
        current = createNestedStateObject(path, routes1, initialRoutes, configs);
        remaining = remainingPath;
        result = current;
    }
    if (current == null || result == null) {
        return undefined;
    }
    return result;
}
var joinPaths = (...paths)=>(_instance = []).concat.apply(_instance, _to_consumable_array._(paths.map((p)=>p.split('/')))).filter(Boolean).join('/');
var matchAgainstConfigs = (remaining, configs)=>{
    var _loop = function(config) {
        if (!config.regex) {
            return "continue";
        }
        var match = remainingPath.match(config.regex);
        // If our regex matches, we need to extract params from the path
        if (match) {
            var _config_pattern;
            var matchResult = (_config_pattern = config.pattern) === null || _config_pattern === void 0 ? void 0 : _config_pattern.split('/').reduce((acc, p, index)=>{
                if (!p.startsWith(':')) {
                    return acc;
                }
                // Path parameter so increment position for the segment
                acc.pos += 1;
                var decodedParamSegment = decodeURIComponent(// The param segments appear every second item starting from 2 in the regex match result
                match[(acc.pos + 1) * 2]// Remove trailing slash
                .replace(/\/$/, ''));
                Object.assign(acc.matchedParams, {
                    [p]: Object.assign(acc.matchedParams[p] || {}, {
                        [index]: decodedParamSegment
                    })
                });
                return acc;
            }, {
                pos: -1,
                matchedParams: {}
            });
            var matchedParams = matchResult.matchedParams || {};
            routes = config.routeNames.map((name)=>{
                var _routeConfig_pattern_replace;
                var routeConfig = configs.find((c)=>{
                    // Check matching name AND pattern in case same screen is used at different levels in config
                    return c.screen === name && config.pattern.startsWith(c.pattern);
                });
                // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
                var normalizedPath = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.path.split('/').filter(Boolean).join('/');
                // Get the number of segments in the initial pattern
                var numInitialSegments = routeConfig === null || routeConfig === void 0 ? void 0 : (_routeConfig_pattern_replace = routeConfig.pattern// Extract the prefix from the pattern by removing the ending path pattern (e.g pattern=`a/b/c/d` and normalizedPath=`c/d` becomes `a/b`)
                .replace(new RegExp(`${(0, _escapestringregexp.default)(normalizedPath)}$`), '')) === null || _routeConfig_pattern_replace === void 0 ? void 0 : _routeConfig_pattern_replace.split('/').length;
                var params = normalizedPath === null || normalizedPath === void 0 ? void 0 : normalizedPath.split('/').reduce((acc, p, index)=>{
                    var _matchedParams_p;
                    if (!p.startsWith(':')) {
                        return acc;
                    }
                    // Get the real index of the path parameter in the matched path
                    // by offsetting by the number of segments in the initial pattern
                    var offset = numInitialSegments ? numInitialSegments - 1 : 0;
                    var value = (_matchedParams_p = matchedParams[p]) === null || _matchedParams_p === void 0 ? void 0 : _matchedParams_p[index + offset];
                    if (value) {
                        var _routeConfig_parse;
                        var key = p.replace(/^:/, '').replace(/\?$/, '');
                        acc[key] = (routeConfig === null || routeConfig === void 0 ? void 0 : (_routeConfig_parse = routeConfig.parse) === null || _routeConfig_parse === void 0 ? void 0 : _routeConfig_parse[key]) ? routeConfig.parse[key](value) : value;
                    }
                    return acc;
                }, {});
                if (params && Object.keys(params).length) {
                    return {
                        name,
                        params
                    };
                }
                return {
                    name
                };
            });
            remainingPath = remainingPath.replace(match[1], '');
            return "break";
        }
    };
    var routes;
    var remainingPath = remaining;
    // Go through all configs, and see if the next path segment matches our regex
    for (var config of configs){
        var _ret = _loop(config);
        if (_ret === "break") break;
    }
    return {
        routes,
        remainingPath
    };
};
var createNormalizedConfigs = (screen, routeConfig, ref, initials, parentScreens, parentPattern)=>{
    var routeNames = ref === void 0 ? [] : ref;
    var configs = [];
    routeNames.push(screen);
    parentScreens.push(screen);
    // @ts-expect-error: we can't strongly typecheck this for now
    var config = routeConfig[screen];
    if (typeof config === 'string') {
        // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
        var pattern = parentPattern ? joinPaths(parentPattern, config) : config;
        configs.push(createConfigItem(screen, routeNames, pattern, config));
    } else if (typeof config === 'object') {
        var pattern1;
        // if an object is specified as the value (e.g. Foo: { ... }),
        // it can have `path` property and
        // it could have `screens` prop which has nested configs
        if (typeof config.path === 'string') {
            if (config.exact && config.path === undefined) {
                throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
            }
            pattern1 = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';
            configs.push(createConfigItem(screen, routeNames, pattern1, config.path, config.parse));
        }
        if (config.screens) {
            // property `initialRouteName` without `screens` has no purpose
            if (config.initialRouteName) {
                initials.push({
                    initialRouteName: config.initialRouteName,
                    parentScreens
                });
            }
            Object.keys(config.screens).forEach((nestedConfig)=>{
                var _configs;
                var result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, _to_consumable_array._(parentScreens), pattern1 ?? parentPattern);
                (_configs = configs).push.apply(_configs, _to_consumable_array._(result));
            });
        }
    }
    routeNames.pop();
    return configs;
};
var createConfigItem = (screen, routeNames, pattern, path, parse)=>{
    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
    pattern = pattern.split('/').filter(Boolean).join('/');
    var regex = pattern ? new RegExp(`^(${pattern.split('/').map((it)=>{
        if (it.startsWith(':')) {
            return `(([^/]+\\/)${it.endsWith('?') ? '?' : ''})`;
        }
        return `${it === '*' ? '.*' : (0, _escapestringregexp.default)(it)}\\/`;
    }).join('')})`) : undefined;
    return {
        screen,
        regex,
        pattern,
        path,
        // The routeNames array is mutated, so copy it to keep the current state
        routeNames: _to_consumable_array._(routeNames),
        parse
    };
};
var findParseConfigForRoute = (routeName, flatConfig)=>{
    for (var config of flatConfig){
        if (routeName === config.routeNames[config.routeNames.length - 1]) {
            return config.parse;
        }
    }
    return undefined;
};
// Try to find an initial route connected with the one passed
var findInitialRoute = (routeName, parentScreens, initialRoutes)=>{
    for (var config of initialRoutes){
        if (parentScreens.length === config.parentScreens.length) {
            var sameParents = true;
            for(var i = 0; i < parentScreens.length; i++){
                if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {
                    sameParents = false;
                    break;
                }
            }
            if (sameParents) {
                return routeName !== config.initialRouteName ? config.initialRouteName : undefined;
            }
        }
    }
    return undefined;
};
// returns state object with values depending on whether
// it is the end of state and if there is initialRoute for this level
var createStateObject = (initialRoute, route, isEmpty)=>{
    if (isEmpty) {
        if (initialRoute) {
            return {
                index: 1,
                routes: [
                    {
                        name: initialRoute
                    },
                    route
                ]
            };
        } else {
            return {
                routes: [
                    route
                ]
            };
        }
    } else {
        if (initialRoute) {
            return {
                index: 1,
                routes: [
                    {
                        name: initialRoute
                    },
                    _object_spread_props._(_object_spread._({}, route), {
                        state: {
                            routes: []
                        }
                    })
                ]
            };
        } else {
            return {
                routes: [
                    _object_spread_props._(_object_spread._({}, route), {
                        state: {
                            routes: []
                        }
                    })
                ]
            };
        }
    }
};
var createNestedStateObject = (path, routes, initialRoutes, flatConfig)=>{
    var state;
    var route = routes.shift();
    var parentScreens = [];
    var initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
    parentScreens.push(route.name);
    state = createStateObject(initialRoute, route, routes.length === 0);
    if (routes.length > 0) {
        var nestedState = state;
        while(route = routes.shift()){
            initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
            var nestedStateIndex = nestedState.index || nestedState.routes.length - 1;
            nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);
            if (routes.length > 0) {
                nestedState = nestedState.routes[nestedStateIndex].state;
            }
            parentScreens.push(route.name);
        }
    }
    route = (0, _findFocusedRoute.default)(state);
    route.path = path;
    var params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);
    if (params) {
        route.params = _object_spread._({}, route.params, params);
    }
    return state;
};
var parseQueryParams = (path, parseConfig)=>{
    var query = path.split('?')[1];
    var params = _querystring.parse(query);
    if (parseConfig) {
        Object.keys(params).forEach((name)=>{
            if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {
                params[name] = parseConfig[name](params[name]);
            }
        });
    }
    return Object.keys(params).length ? params : undefined;
};


}),
39511: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get BaseNavigationContainer () {
        return _BaseNavigationContainer.default;
    },
    get CurrentRenderContext () {
        return _CurrentRenderContext.default;
    },
    get NavigationContainerRefContext () {
        return _NavigationContainerRefContext.default;
    },
    get NavigationContext () {
        return _NavigationContext.default;
    },
    get NavigationHelpersContext () {
        return _NavigationHelpersContext.default;
    },
    get NavigationRouteContext () {
        return _NavigationRouteContext.default;
    },
    get PreventRemoveContext () {
        return _PreventRemoveContext.default;
    },
    get PreventRemoveProvider () {
        return _PreventRemoveProvider.default;
    },
    get UNSTABLE_usePreventRemove () {
        return _usePreventRemove.default;
    },
    get createNavigationContainerRef () {
        return _createNavigationContainerRef.default;
    },
    get createNavigatorFactory () {
        return _createNavigatorFactory.default;
    },
    get findFocusedRoute () {
        return _findFocusedRoute.default;
    },
    get getActionFromState () {
        return _getActionFromState.default;
    },
    get getFocusedRouteNameFromRoute () {
        return _getFocusedRouteNameFromRoute.default;
    },
    get getPathFromState () {
        return _getPathFromState.default;
    },
    get getStateFromPath () {
        return _getStateFromPath.default;
    },
    get useFocusEffect () {
        return _useFocusEffect.default;
    },
    get useIsFocused () {
        return _useIsFocused.default;
    },
    get useNavigation () {
        return _useNavigation.default;
    },
    get useNavigationBuilder () {
        return _useNavigationBuilder.default;
    },
    get useNavigationContainerRef () {
        return _useNavigationContainerRef.default;
    },
    get useNavigationState () {
        return _useNavigationState.default;
    },
    get usePreventRemoveContext () {
        return _usePreventRemoveContext.default;
    },
    get useRoute () {
        return _useRoute.default;
    },
    get validatePathConfig () {
        return _validatePathConfig.default;
    }
});
var _export_star = __webpack_require__(80010);
var _interop_require_default = __webpack_require__(92766);
var _BaseNavigationContainer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(5348));
var _createNavigationContainerRef = /*#__PURE__*/ _interop_require_default._(__webpack_require__(409));
var _createNavigatorFactory = /*#__PURE__*/ _interop_require_default._(__webpack_require__(87341));
var _CurrentRenderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(47023));
var _findFocusedRoute = /*#__PURE__*/ _interop_require_default._(__webpack_require__(39700));
var _getActionFromState = /*#__PURE__*/ _interop_require_default._(__webpack_require__(10640));
var _getFocusedRouteNameFromRoute = /*#__PURE__*/ _interop_require_default._(__webpack_require__(63695));
var _getPathFromState = /*#__PURE__*/ _interop_require_default._(__webpack_require__(89656));
var _getStateFromPath = /*#__PURE__*/ _interop_require_default._(__webpack_require__(37568));
var _NavigationContainerRefContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(61338));
var _NavigationContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(67423));
var _NavigationHelpersContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(75388));
var _NavigationRouteContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98405));
var _PreventRemoveContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(24889));
var _PreventRemoveProvider = /*#__PURE__*/ _interop_require_default._(__webpack_require__(5102));
_export_star._(__webpack_require__(55112), exports);
var _useFocusEffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(97475));
var _useIsFocused = /*#__PURE__*/ _interop_require_default._(__webpack_require__(7167));
var _useNavigation = /*#__PURE__*/ _interop_require_default._(__webpack_require__(13065));
var _useNavigationBuilder = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98712));
var _useNavigationContainerRef = /*#__PURE__*/ _interop_require_default._(__webpack_require__(55539));
var _useNavigationState = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69103));
var _usePreventRemove = /*#__PURE__*/ _interop_require_default._(__webpack_require__(15488));
var _usePreventRemoveContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(67914));
var _useRoute = /*#__PURE__*/ _interop_require_default._(__webpack_require__(46616));
var _validatePathConfig = /*#__PURE__*/ _interop_require_default._(__webpack_require__(12853));
_export_star._(__webpack_require__(76951), exports);


}),
39683: (function (__unused_webpack_module, exports) {
/**
 * Compare two arrays with primitive values as the content.
 * We need to make sure that both values and order match.
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return isArrayEqual;
    }
}));
function isArrayEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (a.length !== b.length) {
        return false;
    }
    return a.every((it, index)=>it === b[index]);
}


}),
77378: (function (__unused_webpack_module, exports) {
/**
 * Compare two records with primitive values as the content.
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return isRecordEqual;
    }
}));
function isRecordEqual(a, b) {
    if (a === b) {
        return true;
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
        return false;
    }
    return aKeys.every((key)=>a[key] === b[key]);
}


}),
55112: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "PrivateValueStore", ({
    enumerable: true,
    get: function() {
        return PrivateValueStore;
    }
}));
var _class_call_check = __webpack_require__(83457);
var PrivateValueStore = function PrivateValueStore() {
    "use strict";
    _class_call_check._(this, PrivateValueStore);
};


}),
74964: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useChildListeners;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
function useChildListeners() {
    var _React_useRef = _react.useRef({
        action: [],
        focus: []
    }), listeners = _React_useRef.current;
    var addListener = _react.useCallback((type, listener)=>{
        listeners[type].push(listener);
        var removed = false;
        return ()=>{
            var index = listeners[type].indexOf(listener);
            if (!removed && index > -1) {
                removed = true;
                listeners[type].splice(index, 1);
            }
        };
    }, [
        listeners
    ]);
    return {
        listeners,
        addListener
    };
}


}),
52202: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useComponent;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _jsxruntime = __webpack_require__(53083);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var NavigationContent = (ref)=>{
    var render = ref.render, children = ref.children;
    return render(children);
};
function useComponent(render) {
    var renderRef = _react.useRef(render);
    // Normally refs shouldn't be mutated in render
    // But we return a component which will be rendered
    // So it's just for immediate consumption
    renderRef.current = render;
    _react.useEffect(()=>{
        renderRef.current = null;
    });
    return _react.useRef((ref)=>{
        var children = ref.children;
        var _$render = renderRef.current;
        if (_$render === null) {
            throw new Error('The returned component must be rendered in the same render phase as the hook.');
        }
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(NavigationContent, {
            render: _$render,
            children: children
        });
    }).current;
}


}),
83291: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useCurrentRender;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _CurrentRenderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(47023));
function useCurrentRender(ref) {
    var state = ref.state, navigation = ref.navigation, descriptors = ref.descriptors;
    var current = _react.useContext(_CurrentRenderContext.default);
    if (current && navigation.isFocused()) {
        current.options = descriptors[state.routes[state.index].key].options;
    }
}


}),
99969: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useDescriptors;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_without_properties = __webpack_require__(67334);
var _sliced_to_array = __webpack_require__(30067);
var _to_consumable_array = __webpack_require__(60116);
var _to_property_key = __webpack_require__(28102);
var _jsxruntime = __webpack_require__(53083);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationBuilderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69489));
var _NavigationContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(67423));
var _NavigationRouteContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98405));
var _SceneView = /*#__PURE__*/ _interop_require_default._(__webpack_require__(87803));
var _useNavigationCache = /*#__PURE__*/ _interop_require_default._(__webpack_require__(45279));
var _useRouteCache = /*#__PURE__*/ _interop_require_default._(__webpack_require__(41207));
function useDescriptors(ref) {
    var state = ref.state, screens = ref.screens, navigation = ref.navigation, screenOptions = ref.screenOptions, defaultScreenOptions = ref.defaultScreenOptions, onAction = ref.onAction, getState = ref.getState, setState = ref.setState, addListener = ref.addListener, addKeyedListener = ref.addKeyedListener, onRouteFocus = ref.onRouteFocus, router = ref.router, emitter = ref.emitter;
    var _React_useState = _sliced_to_array._(_react.useState({}), 2), options = _React_useState[0], setOptions = _React_useState[1];
    var _React_useContext = _react.useContext(_NavigationBuilderContext.default), onDispatchAction = _React_useContext.onDispatchAction, onOptionsChange = _React_useContext.onOptionsChange, stackRef = _React_useContext.stackRef;
    var context = _react.useMemo(()=>({
            navigation,
            onAction,
            addListener,
            addKeyedListener,
            onRouteFocus,
            onDispatchAction,
            onOptionsChange,
            stackRef
        }), [
        navigation,
        onAction,
        addListener,
        addKeyedListener,
        onRouteFocus,
        onDispatchAction,
        onOptionsChange,
        stackRef
    ]);
    var navigations = (0, _useNavigationCache.default)({
        state,
        getState,
        navigation,
        setOptions,
        router,
        emitter
    });
    var routes = (0, _useRouteCache.default)(state.routes);
    return routes.reduce((acc, route, i)=>{
        var config = screens[route.name];
        var screen = config.props;
        var navigation = navigations[route.key];
        var optionsList = [
            // The default `screenOptions` passed to the navigator
            screenOptions
        ].concat(// The `screenOptions` props passed to `Group` elements
        _to_consumable_array._(config.options ? config.options.filter(Boolean) : []), [
            // The `options` prop passed to `Screen` elements,
            screen.options,
            // The options set via `navigation.setOptions`
            options[route.key]
        ]);
        var customOptions = optionsList.reduce((acc, curr)=>Object.assign(acc, // @ts-expect-error: we check for function but TS still complains
            typeof curr !== 'function' ? curr : curr({
                route,
                navigation
            })), {});
        var mergedOptions = _object_spread._({}, typeof defaultScreenOptions === 'function' ? defaultScreenOptions({
            route,
            navigation,
            options: customOptions
        }) : defaultScreenOptions, customOptions);
        var clearOptions = ()=>setOptions((o)=>{
                if (route.key in o) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    var _route_key = route.key, _ = o[_route_key], rest = _object_without_properties._(o, [
                        _route_key
                    ].map(_to_property_key._));
                    return rest;
                }
                return o;
            });
        acc[route.key] = {
            route,
            // @ts-expect-error: it's missing action helpers, fix later
            navigation,
            render () {
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationBuilderContext.default.Provider, {
                    value: context,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationContext.default.Provider, {
                        value: navigation,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationRouteContext.default.Provider, {
                            value: route,
                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_SceneView.default, {
                                navigation: navigation,
                                route: route,
                                screen: screen,
                                routeState: state.routes[i].state,
                                getState: getState,
                                setState: setState,
                                options: mergedOptions,
                                clearOptions: clearOptions
                            })
                        })
                    })
                }, route.key);
            },
            options: mergedOptions
        };
        return acc;
    }, {});
}


}),
27029: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useEventEmitter;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _to_consumable_array = __webpack_require__(60116);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
function useEventEmitter(listen) {
    var listenRef = _react.useRef(listen);
    _react.useEffect(()=>{
        listenRef.current = listen;
    });
    var listeners = _react.useRef(Object.create(null));
    var create = _react.useCallback((target)=>{
        var removeListener = (type, callback)=>{
            var callbacks = listeners.current[type] ? listeners.current[type][target] : undefined;
            if (!callbacks) {
                return;
            }
            var index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        };
        var addListener = (type, callback)=>{
            listeners.current[type] = listeners.current[type] || {};
            listeners.current[type][target] = listeners.current[type][target] || [];
            listeners.current[type][target].push(callback);
            var removed = false;
            return ()=>{
                // Prevent removing other listeners when unsubscribing same listener multiple times
                if (!removed) {
                    removed = true;
                    removeListener(type, callback);
                }
            };
        };
        return {
            addListener,
            removeListener
        };
    }, []);
    var emit = _react.useCallback((ref)=>{
        var type = ref.type, data = ref.data, target = ref.target, canPreventDefault = ref.canPreventDefault;
        var _instance;
        var _items_target, _listenRef_current;
        var items = listeners.current[type] || {};
        // Copy the current list of callbacks in case they are mutated during execution
        var callbacks = target !== undefined ? (_items_target = items[target]) === null || _items_target === void 0 ? void 0 : _items_target.slice() : (_instance = []).concat.apply(_instance, _to_consumable_array._(Object.keys(items).map((t)=>items[t]))).filter((cb, i, self)=>self.lastIndexOf(cb) === i);
        var event = {
            get type () {
                return type;
            }
        };
        if (target !== undefined) {
            Object.defineProperty(event, 'target', {
                enumerable: true,
                get () {
                    return target;
                }
            });
        }
        if (data !== undefined) {
            Object.defineProperty(event, 'data', {
                enumerable: true,
                get () {
                    return data;
                }
            });
        }
        if (canPreventDefault) {
            var defaultPrevented = false;
            Object.defineProperties(event, {
                defaultPrevented: {
                    enumerable: true,
                    get () {
                        return defaultPrevented;
                    }
                },
                preventDefault: {
                    enumerable: true,
                    value () {
                        defaultPrevented = true;
                    }
                }
            });
        }
        (_listenRef_current = listenRef.current) === null || _listenRef_current === void 0 ? void 0 : _listenRef_current.call(listenRef, event);
        callbacks === null || callbacks === void 0 ? void 0 : callbacks.forEach((cb)=>cb(event));
        return event;
    }, []);
    return _react.useMemo(()=>({
            create,
            emit
        }), [
        create,
        emit
    ]);
}


}),
97475: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useFocusEffect;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _useNavigation = /*#__PURE__*/ _interop_require_default._(__webpack_require__(13065));
function useFocusEffect(effect) {
    var navigation = (0, _useNavigation.default)();
    if (arguments[1] !== undefined) {
        var message = "You passed a second argument to 'useFocusEffect', but it only accepts one argument. " + "If you want to pass a dependency array, you can use 'React.useCallback':\n\n" + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    // Your code here\n' + '  }, [depA, depB])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
        console.error(message);
    }
    _react.useEffect(()=>{
        var isFocused = false;
        var cleanup;
        var callback = ()=>{
            var destroy = effect();
            if (destroy === undefined || typeof destroy === 'function') {
                return destroy;
            }
            if (false) { var message }
        };
        // We need to run the effect on intial render/dep changes if the screen is focused
        if (navigation.isFocused()) {
            cleanup = callback();
            isFocused = true;
        }
        var unsubscribeFocus = navigation.addListener('focus', ()=>{
            // If callback was already called for focus, avoid calling it again
            // The focus event may also fire on intial render, so we guard against runing the effect twice
            if (isFocused) {
                return;
            }
            if (cleanup !== undefined) {
                cleanup();
            }
            cleanup = callback();
            isFocused = true;
        });
        var unsubscribeBlur = navigation.addListener('blur', ()=>{
            if (cleanup !== undefined) {
                cleanup();
            }
            cleanup = undefined;
            isFocused = false;
        });
        return ()=>{
            if (cleanup !== undefined) {
                cleanup();
            }
            unsubscribeFocus();
            unsubscribeBlur();
        };
    }, [
        effect,
        navigation
    ]);
}


}),
33106: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useFocusEvents;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(67423));
function useFocusEvents(ref) {
    var state = ref.state, emitter = ref.emitter;
    var navigation = _react.useContext(_NavigationContext.default);
    var lastFocusedKeyRef = _react.useRef();
    var currentFocusedKey = state.routes[state.index].key;
    // When the parent screen changes its focus state, we also need to change child's focus
    // Coz the child screen can't be focused if the parent screen is out of focus
    _react.useEffect(()=>navigation === null || navigation === void 0 ? void 0 : navigation.addListener('focus', ()=>{
            lastFocusedKeyRef.current = currentFocusedKey;
            emitter.emit({
                type: 'focus',
                target: currentFocusedKey
            });
        }), [
        currentFocusedKey,
        emitter,
        navigation
    ]);
    _react.useEffect(()=>navigation === null || navigation === void 0 ? void 0 : navigation.addListener('blur', ()=>{
            lastFocusedKeyRef.current = undefined;
            emitter.emit({
                type: 'blur',
                target: currentFocusedKey
            });
        }), [
        currentFocusedKey,
        emitter,
        navigation
    ]);
    _react.useEffect(()=>{
        var lastFocusedKey = lastFocusedKeyRef.current;
        lastFocusedKeyRef.current = currentFocusedKey;
        // We wouldn't have `lastFocusedKey` on initial mount
        // Fire focus event for the current route on mount if there's no parent navigator
        if (lastFocusedKey === undefined && !navigation) {
            emitter.emit({
                type: 'focus',
                target: currentFocusedKey
            });
        }
        // We should only emit events when the focused key changed and navigator is focused
        // When navigator is not focused, screens inside shouldn't receive focused status either
        if (lastFocusedKey === currentFocusedKey || !(navigation ? navigation.isFocused() : true)) {
            return;
        }
        if (lastFocusedKey === undefined) {
            // Only fire events after initial mount
            return;
        }
        emitter.emit({
            type: 'blur',
            target: lastFocusedKey
        });
        emitter.emit({
            type: 'focus',
            target: currentFocusedKey
        });
    }, [
        currentFocusedKey,
        emitter,
        navigation
    ]);
}


}),
9618: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useFocusedListenersChildrenAdapter;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationBuilderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69489));
function useFocusedListenersChildrenAdapter(ref) {
    var navigation = ref.navigation, focusedListeners = ref.focusedListeners;
    var addListener = _react.useContext(_NavigationBuilderContext.default).addListener;
    var listener = _react.useCallback((callback)=>{
        if (navigation.isFocused()) {
            for (var listener of focusedListeners){
                var _listener = listener(callback), handled = _listener.handled, result = _listener.result;
                if (handled) {
                    return {
                        handled,
                        result
                    };
                }
            }
            return {
                handled: true,
                result: callback(navigation)
            };
        } else {
            return {
                handled: false,
                result: null
            };
        }
    }, [
        focusedListeners,
        navigation
    ]);
    _react.useEffect(()=>addListener === null || addListener === void 0 ? void 0 : addListener('focus', listener), [
        addListener,
        listener
    ]);
}


}),
7167: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useIsFocused;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _sliced_to_array = __webpack_require__(30067);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _useNavigation = /*#__PURE__*/ _interop_require_default._(__webpack_require__(13065));
function useIsFocused() {
    var navigation = (0, _useNavigation.default)();
    var _useState = _sliced_to_array._((0, _react.useState)(navigation.isFocused), 2), isFocused = _useState[0], setIsFocused = _useState[1];
    var valueToReturn = navigation.isFocused();
    if (isFocused !== valueToReturn) {
        // If the value has changed since the last render, we need to update it.
        // This could happen if we missed an update from the event listeners during re-render.
        // React will process this update immediately, so the old subscription value won't be committed.
        // It is still nice to avoid returning a mismatched value though, so let's override the return value.
        // This is the same logic as in https://github.com/facebook/react/tree/master/packages/use-subscription
        setIsFocused(valueToReturn);
    }
    _react.useEffect(()=>{
        var unsubscribeFocus = navigation.addListener('focus', ()=>setIsFocused(true));
        var unsubscribeBlur = navigation.addListener('blur', ()=>setIsFocused(false));
        return ()=>{
            unsubscribeFocus();
            unsubscribeBlur();
        };
    }, [
        navigation
    ]);
    _react.useDebugValue(valueToReturn);
    return valueToReturn;
}


}),
49608: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useKeyedChildListeners;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
function useKeyedChildListeners() {
    var _React_useRef = _react.useRef(Object.assign(Object.create(null), {
        getState: {},
        beforeRemove: {}
    })), keyedListeners = _React_useRef.current;
    var addKeyedListener = _react.useCallback((type, key, listener)=>{
        // @ts-expect-error: according to ref stated above you can use `key` to index type
        keyedListeners[type][key] = listener;
        return ()=>{
            // @ts-expect-error: according to ref stated above you can use `key` to index type
            keyedListeners[type][key] = undefined;
        };
    }, [
        keyedListeners
    ]);
    return {
        keyedListeners,
        addKeyedListener
    };
}


}),
13065: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useNavigation;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationContainerRefContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(61338));
var _NavigationContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(67423));
function useNavigation() {
    var root = _react.useContext(_NavigationContainerRefContext.default);
    var navigation = _react.useContext(_NavigationContext.default);
    if (navigation === undefined && root === undefined) {
        throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    // FIXME: Figure out a better way to do this
    return navigation ?? root;
}


}),
98712: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useNavigationBuilder;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_without_properties = __webpack_require__(67334);
var _sliced_to_array = __webpack_require__(30067);
var _to_consumable_array = __webpack_require__(60116);
var _jsxruntime = __webpack_require__(53083);
var _routers = __webpack_require__(76951);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _reactis = __webpack_require__(12962);
var _Group = /*#__PURE__*/ _interop_require_default._(__webpack_require__(45090));
var _isArrayEqual = /*#__PURE__*/ _interop_require_default._(__webpack_require__(39683));
var _isRecordEqual = /*#__PURE__*/ _interop_require_default._(__webpack_require__(77378));
var _NavigationHelpersContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(75388));
var _NavigationRouteContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98405));
var _NavigationStateContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(83203));
var _PreventRemoveProvider = /*#__PURE__*/ _interop_require_default._(__webpack_require__(5102));
var _Screen = /*#__PURE__*/ _interop_require_default._(__webpack_require__(83525));
var _types = __webpack_require__(55112);
var _useChildListeners = /*#__PURE__*/ _interop_require_default._(__webpack_require__(74964));
var _useComponent = /*#__PURE__*/ _interop_require_default._(__webpack_require__(52202));
var _useCurrentRender = /*#__PURE__*/ _interop_require_default._(__webpack_require__(83291));
var _useDescriptors = /*#__PURE__*/ _interop_require_default._(__webpack_require__(99969));
var _useEventEmitter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27029));
var _useFocusedListenersChildrenAdapter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(9618));
var _useFocusEvents = /*#__PURE__*/ _interop_require_default._(__webpack_require__(33106));
var _useKeyedChildListeners = /*#__PURE__*/ _interop_require_default._(__webpack_require__(49608));
var _useNavigationHelpers = /*#__PURE__*/ _interop_require_default._(__webpack_require__(30953));
var _useOnAction = /*#__PURE__*/ _interop_require_default._(__webpack_require__(54218));
var _useOnGetState = /*#__PURE__*/ _interop_require_default._(__webpack_require__(85070));
var _useOnRouteFocus = /*#__PURE__*/ _interop_require_default._(__webpack_require__(97707));
var _useRegisterNavigator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(15901));
var _useScheduleUpdate = /*#__PURE__*/ _interop_require_default._(__webpack_require__(47392));
// This is to make TypeScript compiler happy
// eslint-disable-next-line babel/no-unused-expressions
_types.PrivateValueStore;
var isValidKey = (key)=>key === undefined || typeof key === 'string' && key !== '';
/**
 * Extract route config object from React children elements.
 *
 * @param children React Elements to extract the config from.
 */ var getRouteConfigsFromChildren = (children, groupKey, groupOptions)=>{
    var configs = _react.Children.toArray(children).reduce((acc, child)=>{
        var _child_type, _child_props;
        if (/*#__PURE__*/ _react.isValidElement(child)) {
            if (child.type === _Screen.default) {
                // We can only extract the config from `Screen` elements
                // If something else was rendered, it's probably a bug
                if (!isValidKey(child.props.navigationKey)) {
                    throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the screen '${child.props.name}'. It must be a non-empty string or 'undefined'.`);
                }
                acc.push({
                    keys: [
                        groupKey,
                        child.props.navigationKey
                    ],
                    options: groupOptions,
                    props: child.props
                });
                return acc;
            }
            if (child.type === _react.Fragment || child.type === _Group.default) {
                var // When we encounter a fragment or group, we need to dive into its children to extract the configs
                // This is handy to conditionally define a group of screens
                _acc;
                if (!isValidKey(child.props.navigationKey)) {
                    throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the group. It must be a non-empty string or 'undefined'.`);
                }
                (_acc = acc).push.apply(_acc, _to_consumable_array._(getRouteConfigsFromChildren(child.props.children, child.props.navigationKey, child.type !== _Group.default ? groupOptions : groupOptions != null ? _to_consumable_array._(groupOptions).concat([
                    child.props.screenOptions
                ]) : [
                    child.props.screenOptions
                ])));
                return acc;
            }
        }
        throw new Error(`A navigator can only contain 'Screen', 'Group' or 'React.Fragment' as its direct children (found ${/*#__PURE__*/ _react.isValidElement(child) ? `'${typeof child.type === 'string' ? child.type : (_child_type = child.type) === null || _child_type === void 0 ? void 0 : _child_type.name}'${child.props != null && typeof child.props === 'object' && 'name' in child.props && ((_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props.name) ? ` for the screen '${child.props.name}'` : ''}` : typeof child === 'object' ? JSON.stringify(child) : `'${String(child)}'`}). To render this component in the navigator, pass it in the 'component' prop to 'Screen'.`);
    }, []);
    if (false) {}
    return configs;
};
function useNavigationBuilder(createRouter, options) {
    var navigatorKey = (0, _useRegisterNavigator.default)();
    var route = _react.useContext(_NavigationRouteContext.default);
    var children = options.children, screenListeners = options.screenListeners, rest = _object_without_properties._(options, [
        "children",
        "screenListeners"
    ]);
    var _React_useRef = _react.useRef(createRouter(_object_spread._({}, rest, (route === null || route === void 0 ? void 0 : route.params) && route.params.state == null && route.params.initial !== false && typeof route.params.screen === 'string' ? {
        initialRouteName: route.params.screen
    } : null))), router = _React_useRef.current;
    var routeConfigs = getRouteConfigsFromChildren(children);
    var screens = routeConfigs.reduce((acc, config)=>{
        if (config.props.name in acc) {
            throw new Error(`A navigator cannot contain multiple 'Screen' components with the same name (found duplicate screen named '${config.props.name}')`);
        }
        acc[config.props.name] = config;
        return acc;
    }, {});
    var routeNames = routeConfigs.map((config)=>config.props.name);
    var routeKeyList = routeNames.reduce((acc, curr)=>{
        acc[curr] = screens[curr].keys.map((key)=>key ?? '').join(':');
        return acc;
    }, {});
    var routeParamList = routeNames.reduce((acc, curr)=>{
        var initialParams = screens[curr].props.initialParams;
        acc[curr] = initialParams;
        return acc;
    }, {});
    var routeGetIdList = routeNames.reduce((acc, curr)=>Object.assign(acc, {
            [curr]: screens[curr].props.getId
        }), {});
    if (!routeNames.length) {
        throw new Error("Couldn't find any screens for the navigator. Have you defined any screens as its children?");
    }
    var isStateValid = _react.useCallback((state)=>state.type === undefined || state.type === router.type, [
        router.type
    ]);
    var isStateInitialized = _react.useCallback((state)=>state !== undefined && state.stale === false && isStateValid(state), [
        isStateValid
    ]);
    var _React_useContext = _react.useContext(_NavigationStateContext.default), currentState = _React_useContext.state, getCurrentState = _React_useContext.getState, setCurrentState = _React_useContext.setState, setKey = _React_useContext.setKey, getKey = _React_useContext.getKey, getIsInitial = _React_useContext.getIsInitial;
    var stateCleanedUp = _react.useRef(false);
    var cleanUpState = _react.useCallback(()=>{
        setCurrentState(undefined);
        stateCleanedUp.current = true;
    }, [
        setCurrentState
    ]);
    var setState = _react.useCallback((state)=>{
        if (stateCleanedUp.current) {
            // State might have been already cleaned up due to unmount
            // We do not want to expose API allowing to override this
            // This would lead to old data preservation on main navigator unmount
            return;
        }
        setCurrentState(state);
    }, [
        setCurrentState
    ]);
    var _React_useMemo = _sliced_to_array._(_react.useMemo(()=>{
        var _route_params;
        var initialRouteParamList = routeNames.reduce((acc, curr)=>{
            var _route_params, _route_params1, _route_params2;
            var initialParams = screens[curr].props.initialParams;
            var initialParamsFromParams = (route === null || route === void 0 ? void 0 : (_route_params = route.params) === null || _route_params === void 0 ? void 0 : _route_params.state) == null && (route === null || route === void 0 ? void 0 : (_route_params1 = route.params) === null || _route_params1 === void 0 ? void 0 : _route_params1.initial) !== false && (route === null || route === void 0 ? void 0 : (_route_params2 = route.params) === null || _route_params2 === void 0 ? void 0 : _route_params2.screen) === curr ? route.params.params : undefined;
            acc[curr] = initialParams !== undefined || initialParamsFromParams !== undefined ? _object_spread._({}, initialParams, initialParamsFromParams) : undefined;
            return acc;
        }, {});
        // If the current state isn't initialized on first render, we initialize it
        // We also need to re-initialize it if the state passed from parent was changed (maybe due to reset)
        // Otherwise assume that the state was provided as initial state
        // So we need to rehydrate it to make it usable
        if ((currentState === undefined || !isStateValid(currentState)) && (route === null || route === void 0 ? void 0 : (_route_params = route.params) === null || _route_params === void 0 ? void 0 : _route_params.state) == null) {
            return [
                router.getInitialState({
                    routeNames,
                    routeParamList: initialRouteParamList,
                    routeGetIdList
                }),
                true
            ];
        } else {
            var _route_params1;
            return [
                router.getRehydratedState((route === null || route === void 0 ? void 0 : (_route_params1 = route.params) === null || _route_params1 === void 0 ? void 0 : _route_params1.state) ?? currentState, {
                    routeNames,
                    routeParamList: initialRouteParamList,
                    routeGetIdList
                }),
                false
            ];
        }
    // We explicitly don't include routeNames, route.params etc. in the dep list
    // below. We want to avoid forcing a new state to be calculated in those cases
    // Instead, we handle changes to these in the nextState code below. Note
    // that some changes to routeConfigs are explicitly ignored, such as changes
    // to initialParams
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        currentState,
        router,
        isStateValid
    ]), 2), initializedState = _React_useMemo[0], isFirstStateInitialization = _React_useMemo[1];
    var previousRouteKeyListRef = _react.useRef(routeKeyList);
    _react.useEffect(()=>{
        previousRouteKeyListRef.current = routeKeyList;
    });
    var previousRouteKeyList = previousRouteKeyListRef.current;
    var state = // If the state isn't initialized, or stale, use the state we initialized instead
    // The state won't update until there's a change needed in the state we have initalized locally
    // So it'll be `undefined` or stale until the first navigation event happens
    isStateInitialized(currentState) ? currentState : initializedState;
    var nextState = state;
    if (!(0, _isArrayEqual.default)(state.routeNames, routeNames) || !(0, _isRecordEqual.default)(routeKeyList, previousRouteKeyList)) {
        // When the list of route names change, the router should handle it to remove invalid routes
        nextState = router.getStateForRouteNamesChange(state, {
            routeNames,
            routeParamList,
            routeGetIdList,
            routeKeyChanges: Object.keys(routeKeyList).filter((name)=>previousRouteKeyList.hasOwnProperty(name) && routeKeyList[name] !== previousRouteKeyList[name])
        });
    }
    var previousNestedParamsRef = _react.useRef(route === null || route === void 0 ? void 0 : route.params);
    _react.useEffect(()=>{
        previousNestedParamsRef.current = route === null || route === void 0 ? void 0 : route.params;
    }, [
        route === null || route === void 0 ? void 0 : route.params
    ]);
    if (route === null || route === void 0 ? void 0 : route.params) {
        var previousParams = previousNestedParamsRef.current;
        var action;
        if (typeof route.params.state === 'object' && route.params.state != null && route.params !== previousParams) {
            // If the route was updated with new state, we should reset to it
            action = _routers.CommonActions.reset(route.params.state);
        } else if (typeof route.params.screen === 'string' && (route.params.initial === false && isFirstStateInitialization || route.params !== previousParams)) {
            // If the route was updated with new screen name and/or params, we should navigate there
            action = _routers.CommonActions.navigate({
                name: route.params.screen,
                params: route.params.params,
                path: route.params.path
            });
        }
        // The update should be limited to current navigator only, so we call the router manually
        var updatedState = action ? router.getStateForAction(nextState, action, {
            routeNames,
            routeParamList,
            routeGetIdList
        }) : null;
        nextState = updatedState !== null ? router.getRehydratedState(updatedState, {
            routeNames,
            routeParamList,
            routeGetIdList
        }) : nextState;
    }
    var shouldUpdate = state !== nextState;
    (0, _useScheduleUpdate.default)(()=>{
        if (shouldUpdate) {
            // If the state needs to be updated, we'll schedule an update
            setState(nextState);
        }
    });
    // The up-to-date state will come in next render, but we don't need to wait for it
    // We can't use the outdated state since the screens have changed, which will cause error due to mismatched config
    // So we override the state object we return to use the latest state as soon as possible
    state = nextState;
    _react.useEffect(()=>{
        setKey(navigatorKey);
        if (!getIsInitial()) {
            // If it's not initial render, we need to update the state
            // This will make sure that our container gets notifier of state changes due to new mounts
            // This is necessary for proper screen tracking, URL updates etc.
            setState(nextState);
        }
        return ()=>{
            // We need to clean up state for this navigator on unmount
            // We do it in a timeout because we need to detect if another navigator mounted in the meantime
            // For example, if another navigator has started rendering, we should skip cleanup
            // Otherwise, our cleanup step will cleanup state for the other navigator and re-initialize it
            setTimeout(()=>{
                if (getCurrentState() !== undefined && getKey() === navigatorKey) {
                    cleanUpState();
                }
            }, 0);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    // We initialize this ref here to avoid a new getState getting initialized
    // whenever initializedState changes. We want getState to have access to the
    // latest initializedState, but don't need it to change when that happens
    var initializedStateRef = _react.useRef();
    initializedStateRef.current = initializedState;
    var getState = _react.useCallback(()=>{
        var currentState = getCurrentState();
        return isStateInitialized(currentState) ? currentState : initializedStateRef.current;
    }, [
        getCurrentState,
        isStateInitialized
    ]);
    var emitter = (0, _useEventEmitter.default)((e)=>{
        var _instance;
        var routeNames = [];
        var route;
        if (e.target) {
            route = state.routes.find((route)=>route.key === e.target);
            if (route === null || route === void 0 ? void 0 : route.name) {
                routeNames.push(route.name);
            }
        } else {
            var _routeNames;
            route = state.routes[state.index];
            (_routeNames = routeNames).push.apply(_routeNames, _to_consumable_array._(Object.keys(screens).filter((name)=>(route === null || route === void 0 ? void 0 : route.name) === name)));
        }
        if (route == null) {
            return;
        }
        var navigation = descriptors[route.key].navigation;
        var listeners = (_instance = []).concat.apply(_instance, // Get an array of listeners for all screens + common listeners on navigator
        _to_consumable_array._([
            screenListeners
        ].concat(_to_consumable_array._(routeNames.map((name)=>{
            var listeners = screens[name].props.listeners;
            return listeners;
        }))).map((listeners)=>{
            var map = typeof listeners === 'function' ? listeners({
                route: route,
                navigation
            }) : listeners;
            return map ? Object.keys(map).filter((type)=>type === e.type).map((type)=>map === null || map === void 0 ? void 0 : map[type]) : undefined;
        })))// We don't want same listener to be called multiple times for same event
        // So we remove any duplicate functions from the array
        .filter((cb, i, self)=>cb && self.lastIndexOf(cb) === i);
        listeners.forEach((listener)=>listener === null || listener === void 0 ? void 0 : listener(e));
    });
    (0, _useFocusEvents.default)({
        state,
        emitter
    });
    _react.useEffect(()=>{
        emitter.emit({
            type: 'state',
            data: {
                state
            }
        });
    }, [
        emitter,
        state
    ]);
    var _useChildListeners1 = (0, _useChildListeners.default)(), childListeners = _useChildListeners1.listeners, addListener = _useChildListeners1.addListener;
    var _useKeyedChildListeners1 = (0, _useKeyedChildListeners.default)(), keyedListeners = _useKeyedChildListeners1.keyedListeners, addKeyedListener = _useKeyedChildListeners1.addKeyedListener;
    var onAction = (0, _useOnAction.default)({
        router,
        getState,
        setState,
        key: route === null || route === void 0 ? void 0 : route.key,
        actionListeners: childListeners.action,
        beforeRemoveListeners: keyedListeners.beforeRemove,
        routerConfigOptions: {
            routeNames,
            routeParamList,
            routeGetIdList
        },
        emitter
    });
    var onRouteFocus = (0, _useOnRouteFocus.default)({
        router,
        key: route === null || route === void 0 ? void 0 : route.key,
        getState,
        setState
    });
    var navigation = (0, _useNavigationHelpers.default)({
        id: options.id,
        onAction,
        getState,
        emitter,
        router
    });
    (0, _useFocusedListenersChildrenAdapter.default)({
        navigation,
        focusedListeners: childListeners.focus
    });
    (0, _useOnGetState.default)({
        getState,
        getStateListeners: keyedListeners.getState
    });
    var descriptors = (0, _useDescriptors.default)({
        state,
        screens,
        navigation,
        screenOptions: options.screenOptions,
        defaultScreenOptions: options.defaultScreenOptions,
        onAction,
        getState,
        setState,
        onRouteFocus,
        addListener,
        addKeyedListener,
        router,
        // @ts-expect-error: this should have both core and custom events, but too much work right now
        emitter
    });
    (0, _useCurrentRender.default)({
        state,
        navigation,
        descriptors
    });
    var NavigationContent = (0, _useComponent.default)((children)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationHelpersContext.default.Provider, {
            value: navigation,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_PreventRemoveProvider.default, {
                children: children
            })
        }));
    return {
        state,
        navigation,
        descriptors,
        NavigationContent
    };
}


}),
45279: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useNavigationCache;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _object_without_properties = __webpack_require__(67334);
var _to_consumable_array = __webpack_require__(60116);
var _routers = __webpack_require__(76951);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationBuilderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69489));
function useNavigationCache(ref) {
    var state = ref.state, getState = ref.getState, navigation = ref.navigation, setOptions = ref.setOptions, router = ref.router, emitter = ref.emitter;
    var stackRef = _react.useContext(_NavigationBuilderContext.default).stackRef;
    // Cache object which holds navigation objects for each screen
    // We use `React.useMemo` instead of `React.useRef` coz we want to invalidate it when deps change
    // In reality, these deps will rarely change, if ever
    var cache = _react.useMemo(()=>({
            current: {}
        }), // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        getState,
        navigation,
        setOptions,
        router,
        emitter
    ]);
    var actions = _object_spread._({}, router.actionCreators, _routers.CommonActions);
    cache.current = state.routes.reduce((acc, route)=>{
        var previous = cache.current[route.key];
        if (previous) {
            // If a cached navigation object already exists, reuse it
            acc[route.key] = previous;
        } else {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            var emit = navigation.emit, rest = _object_without_properties._(navigation, [
                "emit"
            ]);
            var dispatch = (thunk)=>{
                var action = typeof thunk === 'function' ? thunk(getState()) : thunk;
                if (action != null) {
                    navigation.dispatch(_object_spread._({
                        source: route.key
                    }, action));
                }
            };
            var withStack = (callback)=>{
                var isStackSet = false;
                try {
                    if (false) {}
                    callback();
                } finally{
                    if (isStackSet && stackRef) {
                        stackRef.current = undefined;
                    }
                }
            };
            var helpers = Object.keys(actions).reduce((acc, name)=>{
                var _actions;
                acc[name] = (...args)=>withStack(()=>// @ts-expect-error: name is a valid key, but TypeScript is dumb
                        dispatch((_actions = actions)[name].apply(_actions, _to_consumable_array._(args))));
                return acc;
            }, {});
            acc[route.key] = _object_spread_props._(_object_spread._({}, rest, helpers, emitter.create(route.key)), {
                dispatch: (thunk)=>withStack(()=>dispatch(thunk)),
                getParent: (id)=>{
                    if (id !== undefined && id === rest.getId()) {
                        // If the passed id is the same as the current navigation id,
                        // we return the cached navigation object for the relevant route
                        return acc[route.key];
                    }
                    return rest.getParent(id);
                },
                setOptions: (options)=>setOptions((o)=>_object_spread_props._(_object_spread._({}, o), {
                            [route.key]: _object_spread._({}, o[route.key], options)
                        })),
                isFocused: ()=>{
                    var state = getState();
                    if (state.routes[state.index].key !== route.key) {
                        return false;
                    }
                    // If the current screen is focused, we also need to check if parent navigator is focused
                    // This makes sure that we return the focus state in the whole tree, not just this navigator
                    return navigation ? navigation.isFocused() : true;
                }
            });
        }
        return acc;
    }, {});
    return cache.current;
}


}),
55539: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useNavigationContainerRef;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _createNavigationContainerRef = /*#__PURE__*/ _interop_require_default._(__webpack_require__(409));
function useNavigationContainerRef() {
    var navigation = _react.useRef(null);
    if (navigation.current == null) {
        navigation.current = (0, _createNavigationContainerRef.default)();
    }
    return navigation.current;
}


}),
30953: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useNavigationHelpers;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _to_consumable_array = __webpack_require__(60116);
var _routers = __webpack_require__(76951);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(67423));
var _types = __webpack_require__(55112);
var _UnhandledActionContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(11366));
// This is to make TypeScript compiler happy
// eslint-disable-next-line babel/no-unused-expressions
_types.PrivateValueStore;
function useNavigationHelpers(ref) {
    var navigatorId = ref.id, onAction = ref.onAction, getState = ref.getState, emitter = ref.emitter, router = ref.router;
    var onUnhandledAction = _react.useContext(_UnhandledActionContext.default);
    var parentNavigationHelpers = _react.useContext(_NavigationContext.default);
    return _react.useMemo(()=>{
        var dispatch = (op)=>{
            var action = typeof op === 'function' ? op(getState()) : op;
            var handled = onAction(action);
            if (!handled) {
                onUnhandledAction === null || onUnhandledAction === void 0 ? void 0 : onUnhandledAction(action);
            }
        };
        var actions = _object_spread._({}, router.actionCreators, _routers.CommonActions);
        var helpers = Object.keys(actions).reduce((acc, name)=>{
            var _actions;
            // @ts-expect-error: name is a valid key, but TypeScript is dumb
            acc[name] = (...args)=>dispatch((_actions = actions)[name].apply(_actions, _to_consumable_array._(args)));
            return acc;
        }, {});
        var navigationHelpers = _object_spread_props._(_object_spread._({}, parentNavigationHelpers, helpers), {
            dispatch,
            emit: emitter.emit,
            isFocused: parentNavigationHelpers ? parentNavigationHelpers.isFocused : ()=>true,
            canGoBack: ()=>{
                var state = getState();
                return router.getStateForAction(state, _routers.CommonActions.goBack(), {
                    routeNames: state.routeNames,
                    routeParamList: {},
                    routeGetIdList: {}
                }) !== null || (parentNavigationHelpers === null || parentNavigationHelpers === void 0 ? void 0 : parentNavigationHelpers.canGoBack()) || false;
            },
            getId: ()=>navigatorId,
            getParent: (id)=>{
                if (id !== undefined) {
                    var current = navigationHelpers;
                    while(current && id !== current.getId()){
                        current = current.getParent();
                    }
                    return current;
                }
                return parentNavigationHelpers;
            },
            getState
        });
        return navigationHelpers;
    }, [
        navigatorId,
        emitter.emit,
        getState,
        onAction,
        onUnhandledAction,
        parentNavigationHelpers,
        router
    ]);
}


}),
69103: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useNavigationState;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _sliced_to_array = __webpack_require__(30067);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _useNavigation = /*#__PURE__*/ _interop_require_default._(__webpack_require__(13065));
function useNavigationState(selector) {
    var navigation = (0, _useNavigation.default)();
    // We don't care about the state value, we run the selector again at the end
    // The state is only to make sure that there's a re-render when we have a new value
    var _React_useState = _sliced_to_array._(_react.useState(()=>selector(navigation.getState())), 2), setResult = _React_useState[1];
    // We store the selector in a ref to avoid re-subscribing listeners every render
    var selectorRef = _react.useRef(selector);
    _react.useEffect(()=>{
        selectorRef.current = selector;
    });
    _react.useEffect(()=>{
        var unsubscribe = navigation.addListener('state', (e)=>{
            setResult(selectorRef.current(e.data.state));
        });
        return unsubscribe;
    }, [
        navigation
    ]);
    return selector(navigation.getState());
}


}),
54218: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useOnAction;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationBuilderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69489));
var _useOnPreventRemove = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(54487));
function useOnAction(ref) {
    var router = ref.router, getState = ref.getState, setState = ref.setState, key = ref.key, actionListeners = ref.actionListeners, beforeRemoveListeners = ref.beforeRemoveListeners, routerConfigOptions = ref.routerConfigOptions, emitter = ref.emitter;
    var _React_useContext = _react.useContext(_NavigationBuilderContext.default), onActionParent = _React_useContext.onAction, onRouteFocusParent = _React_useContext.onRouteFocus, addListenerParent = _React_useContext.addListener, onDispatchAction = _React_useContext.onDispatchAction;
    var routerConfigOptionsRef = _react.useRef(routerConfigOptions);
    _react.useEffect(()=>{
        routerConfigOptionsRef.current = routerConfigOptions;
    });
    var onAction = _react.useCallback((action, ref)=>{
        var visitedNavigators = ref === void 0 ? new Set() : ref;
        var state = getState();
        // Since actions can bubble both up and down, they could come to the same navigator again
        // We keep track of navigators which have already tried to handle the action and return if it's already visited
        if (visitedNavigators.has(state.key)) {
            return false;
        }
        visitedNavigators.add(state.key);
        if (typeof action.target !== 'string' || action.target === state.key) {
            var result = router.getStateForAction(state, action, routerConfigOptionsRef.current);
            // If a target is specified and set to current navigator, the action shouldn't bubble
            // So instead of `null`, we use the state object for such cases to signal that action was handled
            result = result === null && action.target === state.key ? state : result;
            if (result !== null) {
                onDispatchAction(action, state === result);
                if (state !== result) {
                    var isPrevented = (0, _useOnPreventRemove.shouldPreventRemove)(emitter, beforeRemoveListeners, state.routes, result.routes, action);
                    if (isPrevented) {
                        return true;
                    }
                    setState(result);
                }
                if (onRouteFocusParent !== undefined) {
                    // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree
                    // This means we need to focus all of the parent navigators of this navigator as well
                    var shouldFocus = router.shouldActionChangeFocus(action);
                    if (shouldFocus && key !== undefined) {
                        onRouteFocusParent(key);
                    }
                }
                return true;
            }
        }
        if (onActionParent !== undefined) {
            // Bubble action to the parent if the current navigator didn't handle it
            if (onActionParent(action, visitedNavigators)) {
                return true;
            }
        }
        // If the action wasn't handled by current navigator or a parent navigator, let children handle it
        for(var i = actionListeners.length - 1; i >= 0; i--){
            var listener = actionListeners[i];
            if (listener(action, visitedNavigators)) {
                return true;
            }
        }
        return false;
    }, [
        actionListeners,
        beforeRemoveListeners,
        emitter,
        getState,
        key,
        onActionParent,
        onDispatchAction,
        onRouteFocusParent,
        router,
        setState
    ]);
    (0, _useOnPreventRemove.default)({
        getState,
        emitter,
        beforeRemoveListeners
    });
    _react.useEffect(()=>addListenerParent === null || addListenerParent === void 0 ? void 0 : addListenerParent('action', onAction), [
        addListenerParent,
        onAction
    ]);
    return onAction;
}


}),
85070: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useOnGetState;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _isArrayEqual = /*#__PURE__*/ _interop_require_default._(__webpack_require__(39683));
var _NavigationBuilderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69489));
var _NavigationRouteContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98405));
function useOnGetState(ref) {
    var getState = ref.getState, getStateListeners = ref.getStateListeners;
    var addKeyedListener = _react.useContext(_NavigationBuilderContext.default).addKeyedListener;
    var route = _react.useContext(_NavigationRouteContext.default);
    var key = route ? route.key : 'root';
    var getRehydratedState = _react.useCallback(()=>{
        var state = getState();
        // Avoid returning new route objects if we don't need to
        var routes = state.routes.map((route)=>{
            var _getStateListeners_route_key;
            var childState = (_getStateListeners_route_key = getStateListeners[route.key]) === null || _getStateListeners_route_key === void 0 ? void 0 : _getStateListeners_route_key.call(getStateListeners);
            if (route.state === childState) {
                return route;
            }
            return _object_spread_props._(_object_spread._({}, route), {
                state: childState
            });
        });
        if ((0, _isArrayEqual.default)(state.routes, routes)) {
            return state;
        }
        return _object_spread_props._(_object_spread._({}, state), {
            routes
        });
    }, [
        getState,
        getStateListeners
    ]);
    _react.useEffect(()=>{
        return addKeyedListener === null || addKeyedListener === void 0 ? void 0 : addKeyedListener('getState', key, getRehydratedState);
    }, [
        addKeyedListener,
        getRehydratedState,
        key
    ]);
}


}),
54487: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get default () {
        return useOnPreventRemove;
    },
    get shouldPreventRemove () {
        return shouldPreventRemove;
    }
});
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationBuilderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69489));
var _NavigationRouteContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98405));
var VISITED_ROUTE_KEYS = Symbol('VISITED_ROUTE_KEYS');
var shouldPreventRemove = (emitter, beforeRemoveListeners, currentRoutes, nextRoutes, action)=>{
    var nextRouteKeys = nextRoutes.map((route)=>route.key);
    // Call these in reverse order so last screens handle the event first
    var removedRoutes = currentRoutes.filter((route)=>!nextRouteKeys.includes(route.key)).reverse();
    var visitedRouteKeys = // @ts-expect-error: add this property to mark that we've already emitted this action
    action[VISITED_ROUTE_KEYS] ?? new Set();
    var beforeRemoveAction = _object_spread_props._(_object_spread._({}, action), {
        [VISITED_ROUTE_KEYS]: visitedRouteKeys
    });
    for (var route of removedRoutes){
        var _beforeRemoveListeners_route_key;
        if (visitedRouteKeys.has(route.key)) {
            continue;
        }
        // First, we need to check if any child screens want to prevent it
        var isPrevented = (_beforeRemoveListeners_route_key = beforeRemoveListeners[route.key]) === null || _beforeRemoveListeners_route_key === void 0 ? void 0 : _beforeRemoveListeners_route_key.call(beforeRemoveListeners, beforeRemoveAction);
        if (isPrevented) {
            return true;
        }
        visitedRouteKeys.add(route.key);
        var event = emitter.emit({
            type: 'beforeRemove',
            target: route.key,
            data: {
                action: beforeRemoveAction
            },
            canPreventDefault: true
        });
        if (event.defaultPrevented) {
            return true;
        }
    }
    return false;
};
function useOnPreventRemove(ref) {
    var getState = ref.getState, emitter = ref.emitter, beforeRemoveListeners = ref.beforeRemoveListeners;
    var addKeyedListener = _react.useContext(_NavigationBuilderContext.default).addKeyedListener;
    var route = _react.useContext(_NavigationRouteContext.default);
    var routeKey = route === null || route === void 0 ? void 0 : route.key;
    _react.useEffect(()=>{
        if (routeKey) {
            return addKeyedListener === null || addKeyedListener === void 0 ? void 0 : addKeyedListener('beforeRemove', routeKey, (action)=>{
                var state = getState();
                return shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, [], action);
            });
        }
    }, [
        addKeyedListener,
        beforeRemoveListeners,
        emitter,
        getState,
        routeKey
    ]);
}


}),
97707: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useOnRouteFocus;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationBuilderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69489));
function useOnRouteFocus(ref) {
    var router = ref.router, getState = ref.getState, sourceRouteKey = ref.key, setState = ref.setState;
    var _React_useContext = _react.useContext(_NavigationBuilderContext.default), onRouteFocusParent = _React_useContext.onRouteFocus;
    return _react.useCallback((key)=>{
        var state = getState();
        var result = router.getStateForRouteFocus(state, key);
        if (result !== state) {
            setState(result);
        }
        if (onRouteFocusParent !== undefined && sourceRouteKey !== undefined) {
            onRouteFocusParent(sourceRouteKey);
        }
    }, [
        getState,
        onRouteFocusParent,
        router,
        setState,
        sourceRouteKey
    ]);
}


}),
19645: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useOptionsGetters;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationBuilderContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(69489));
var _NavigationStateContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(83203));
function useOptionsGetters(ref) {
    var key = ref.key, options = ref.options, navigation = ref.navigation;
    var optionsRef = _react.useRef(options);
    var optionsGettersFromChildRef = _react.useRef({});
    var onOptionsChange = _react.useContext(_NavigationBuilderContext.default).onOptionsChange;
    var _React_useContext = _react.useContext(_NavigationStateContext.default), parentAddOptionsGetter = _React_useContext.addOptionsGetter;
    var optionsChangeListener = _react.useCallback(()=>{
        var isFocused = (navigation === null || navigation === void 0 ? void 0 : navigation.isFocused()) ?? true;
        var hasChildren = Object.keys(optionsGettersFromChildRef.current).length;
        if (isFocused && !hasChildren) {
            onOptionsChange(optionsRef.current ?? {});
        }
    }, [
        navigation,
        onOptionsChange
    ]);
    _react.useEffect(()=>{
        optionsRef.current = options;
        optionsChangeListener();
        return navigation === null || navigation === void 0 ? void 0 : navigation.addListener('focus', optionsChangeListener);
    }, [
        navigation,
        options,
        optionsChangeListener
    ]);
    var getOptionsFromListener = _react.useCallback(()=>{
        for(var key in optionsGettersFromChildRef.current){
            if (optionsGettersFromChildRef.current.hasOwnProperty(key)) {
                var _optionsGettersFromChildRef_current_key, _optionsGettersFromChildRef_current;
                var result = (_optionsGettersFromChildRef_current_key = (_optionsGettersFromChildRef_current = optionsGettersFromChildRef.current)[key]) === null || _optionsGettersFromChildRef_current_key === void 0 ? void 0 : _optionsGettersFromChildRef_current_key.call(_optionsGettersFromChildRef_current);
                // null means unfocused route
                if (result !== null) {
                    return result;
                }
            }
        }
        return null;
    }, []);
    var getCurrentOptions = _react.useCallback(()=>{
        var isFocused = (navigation === null || navigation === void 0 ? void 0 : navigation.isFocused()) ?? true;
        if (!isFocused) {
            return null;
        }
        var optionsFromListener = getOptionsFromListener();
        if (optionsFromListener !== null) {
            return optionsFromListener;
        }
        return optionsRef.current;
    }, [
        navigation,
        getOptionsFromListener
    ]);
    _react.useEffect(()=>{
        return parentAddOptionsGetter === null || parentAddOptionsGetter === void 0 ? void 0 : parentAddOptionsGetter(key, getCurrentOptions);
    }, [
        getCurrentOptions,
        parentAddOptionsGetter,
        key
    ]);
    var addOptionsGetter = _react.useCallback((key, getter)=>{
        optionsGettersFromChildRef.current[key] = getter;
        optionsChangeListener();
        return ()=>{
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete optionsGettersFromChildRef.current[key];
            optionsChangeListener();
        };
    }, [
        optionsChangeListener
    ]);
    return {
        addOptionsGetter,
        getCurrentOptions
    };
}


}),
15488: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return usePreventRemove;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _sliced_to_array = __webpack_require__(30067);
var _nonsecure = __webpack_require__(15771);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _uselatestcallback = /*#__PURE__*/ _interop_require_default._(__webpack_require__(85391));
var _useNavigation = /*#__PURE__*/ _interop_require_default._(__webpack_require__(13065));
var _usePreventRemoveContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(67914));
var _useRoute = /*#__PURE__*/ _interop_require_default._(__webpack_require__(46616));
function usePreventRemove(preventRemove, callback) {
    var _React_useState = _sliced_to_array._(_react.useState(()=>(0, _nonsecure.nanoid)()), 1), id = _React_useState[0];
    var navigation = (0, _useNavigation.default)();
    var _useRoute1 = (0, _useRoute.default)(), routeKey = _useRoute1.key;
    var setPreventRemove = (0, _usePreventRemoveContext.default)().setPreventRemove;
    _react.useEffect(()=>{
        setPreventRemove(id, routeKey, preventRemove);
        return ()=>{
            setPreventRemove(id, routeKey, false);
        };
    }, [
        setPreventRemove,
        id,
        routeKey,
        preventRemove
    ]);
    var beforeRemoveListener = (0, _uselatestcallback.default)((e)=>{
        if (!preventRemove) {
            return;
        }
        e.preventDefault();
        callback({
            data: e.data
        });
    });
    _react.useEffect(()=>navigation === null || navigation === void 0 ? void 0 : navigation.addListener('beforeRemove', beforeRemoveListener), [
        navigation,
        beforeRemoveListener
    ]);
}


}),
67914: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return usePreventRemoveContext;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _PreventRemoveContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(24889));
function usePreventRemoveContext() {
    var value = _react.useContext(_PreventRemoveContext.default);
    if (value == null) {
        throw new Error("Couldn't find the prevent remove context. Is your component inside NavigationContent?");
    }
    return value;
}


}),
15901: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useRegisterNavigator;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _sliced_to_array = __webpack_require__(30067);
var _nonsecure = __webpack_require__(15771);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _EnsureSingleNavigator = __webpack_require__(86963);
function useRegisterNavigator() {
    var _React_useState = _sliced_to_array._(_react.useState(()=>(0, _nonsecure.nanoid)()), 1), key = _React_useState[0];
    var container = _react.useContext(_EnsureSingleNavigator.SingleNavigatorContext);
    if (container === undefined) {
        throw new Error("Couldn't register the navigator. Have you wrapped your app with 'NavigationContainer'?\n\nThis can also happen if there are multiple copies of '@react-navigation' packages installed.");
    }
    _react.useEffect(()=>{
        var register = container.register, unregister = container.unregister;
        register(key);
        return ()=>unregister(key);
    }, [
        container,
        key
    ]);
    return key;
}


}),
46616: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useRoute;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _NavigationRouteContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98405));
function useRoute() {
    var route = _react.useContext(_NavigationRouteContext.default);
    if (route === undefined) {
        throw new Error("Couldn't find a route object. Is your component inside a screen in a navigator?");
    }
    return route;
}


}),
41207: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get CHILD_STATE () {
        return CHILD_STATE;
    },
    get /**
 * Hook to cache route props for each screen in the navigator.
 * This lets add warnings and modifications to the route object but keep references between renders.
 */ default () {
        return useRouteCache;
    }
});
var _interop_require_wildcard = __webpack_require__(97427);
var _object_without_properties = __webpack_require__(67334);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var CHILD_STATE = Symbol('CHILD_STATE');
function useRouteCache(routes) {
    // Cache object which holds route objects for each screen
    var cache = _react.useMemo(()=>({
            current: new Map()
        }), []);
    if (true) {
        // We don't want the overhead of creating extra maps every render in prod
        return routes;
    }
    cache.current = routes.reduce((acc, route)=>{
        var previous = cache.current.get(route);
        if (previous) {
            // If a cached route object already exists, reuse it
            acc.set(route, previous);
        } else {
            var state = route.state, proxy = _object_without_properties._(route, [
                "state"
            ]);
            Object.defineProperty(proxy, CHILD_STATE, {
                enumerable: false,
                value: state
            });
            acc.set(route, proxy);
        }
        return acc;
    }, new Map());
    return Array.from(cache.current.values());
}


}),
47392: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get ScheduleUpdateContext () {
        return ScheduleUpdateContext;
    },
    get /**
 * When screen config changes, we want to update the navigator in the same update phase.
 * However, navigation state is in the root component and React won't let us update it from a child.
 * This is a workaround for that, the scheduled update is stored in the ref without actually calling setState.
 * It lets all subsequent updates access the latest state so it stays correct.
 * Then we call setState during after the component updates.
 */ default () {
        return useScheduleUpdate;
    }
});
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var MISSING_CONTEXT_ERROR = "Couldn't find a schedule context.";
var ScheduleUpdateContext = /*#__PURE__*/ _react.createContext({
    scheduleUpdate () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    flushUpdates () {
        throw new Error(MISSING_CONTEXT_ERROR);
    }
});
function useScheduleUpdate(callback) {
    var _React_useContext = _react.useContext(ScheduleUpdateContext), scheduleUpdate = _React_useContext.scheduleUpdate, flushUpdates = _React_useContext.flushUpdates;
    scheduleUpdate(callback);
    _react.useEffect(flushUpdates);
}


}),
66614: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useSyncState;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _sliced_to_array = __webpack_require__(30067);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var UNINTIALIZED_STATE = {};
function useSyncState(initialState) {
    var stateRef = _react.useRef(UNINTIALIZED_STATE);
    var isSchedulingRef = _react.useRef(false);
    var isMountedRef = _react.useRef(true);
    _react.useEffect(()=>{
        isMountedRef.current = true;
        return ()=>{
            isMountedRef.current = false;
        };
    }, []);
    if (stateRef.current === UNINTIALIZED_STATE) {
        stateRef.current = // @ts-expect-error: initialState is a function, but TypeScript doesn't think so
        typeof initialState === 'function' ? initialState() : initialState;
    }
    var _React_useState = _sliced_to_array._(_react.useState(stateRef.current), 2), trackingState = _React_useState[0], setTrackingState = _React_useState[1];
    var getState = _react.useCallback(()=>stateRef.current, []);
    var setState = _react.useCallback((state)=>{
        if (state === stateRef.current || !isMountedRef.current) {
            return;
        }
        stateRef.current = state;
        if (!isSchedulingRef.current) {
            setTrackingState(state);
        }
    }, []);
    var scheduleUpdate = _react.useCallback((callback)=>{
        isSchedulingRef.current = true;
        try {
            callback();
        } finally{
            isSchedulingRef.current = false;
        }
    }, []);
    var flushUpdates = _react.useCallback(()=>{
        if (!isMountedRef.current) {
            return;
        }
        // Make sure that the tracking state is up-to-date.
        // We call it unconditionally, but React should skip the update if state is unchanged.
        setTrackingState(stateRef.current);
    }, []);
    // If we're rendering and the tracking state is out of date, update it immediately
    // This will make sure that our updates are applied as early as possible.
    if (trackingState !== stateRef.current) {
        setTrackingState(stateRef.current);
    }
    var state = stateRef.current;
    _react.useDebugValue(state);
    return [
        state,
        getState,
        setState,
        scheduleUpdate,
        flushUpdates
    ];
}


}),
12853: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return validatePathConfig;
    }
}));
var _sliced_to_array = __webpack_require__(30067);
var formatToList = (items)=>items.map((key)=>`- ${key}`).join('\n');
function validatePathConfig(config, ref) {
    var root = ref === void 0 ? true : ref;
    var validKeys = [
        'initialRouteName',
        'screens'
    ];
    if (!root) {
        validKeys.push('path', 'exact', 'stringify', 'parse');
    }
    var invalidKeys = Object.keys(config).filter((key)=>!validKeys.includes(key));
    if (invalidKeys.length) {
        throw new Error(`Found invalid properties in the configuration:\n${formatToList(invalidKeys)}\n\nDid you forget to specify them under a 'screens' property?\n\nYou can only specify the following properties:\n${formatToList(validKeys)}\n\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`);
    }
    if (config.screens) {
        Object.entries(config.screens).forEach((ref)=>{
            var _ref = _sliced_to_array._(ref, 2), _ = _ref[0], value = _ref[1];
            if (typeof value !== 'string') {
                validatePathConfig(value, false);
            }
        });
    }
}


}),
68798: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return Link;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_without_properties = __webpack_require__(67334);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _reactnative = __webpack_require__(1350);
var _useLinkProps = /*#__PURE__*/ _interop_require_default._(__webpack_require__(24553));
function Link(_param) {
    var to = _param.to, action = _param.action, rest = _object_without_properties._(_param, [
        "to",
        "action"
    ]);
    var props = (0, _useLinkProps.default)({
        to,
        action
    });
    var onPress = (e)=>{
        if ('onPress' in rest) {
            var _rest_onPress;
            (_rest_onPress = rest.onPress) === null || _rest_onPress === void 0 ? void 0 : _rest_onPress.call(rest, e);
        }
        props.onPress(e);
    };
    return /*#__PURE__*/ _react.createElement(_reactnative.Text, _object_spread._({}, props, rest, _reactnative.Platform.select({
        web: {
            onClick: onPress
        },
        default: {
            onPress
        }
    })));
}


}),
27996: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var LinkingContext = /*#__PURE__*/ _react.createContext({
    options: undefined
});
LinkingContext.displayName = 'LinkingContext';
var _default = LinkingContext;


}),
54523: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _object_without_properties = __webpack_require__(67334);
var _sliced_to_array = __webpack_require__(30067);
var _jsxruntime = __webpack_require__(53083);
var _core = __webpack_require__(39511);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _LinkingContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27996));
var _DefaultTheme = /*#__PURE__*/ _interop_require_default._(__webpack_require__(41041));
var _ThemeProvider = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8299));
var _useBackButton = /*#__PURE__*/ _interop_require_default._(__webpack_require__(90210));
var _useDocumentTitle = /*#__PURE__*/ _interop_require_default._(__webpack_require__(5788));
var _useLinking = /*#__PURE__*/ _interop_require_default._(__webpack_require__(83562));
var _useThenable = /*#__PURE__*/ _interop_require_default._(__webpack_require__(51490));
__webpack_require__.g.REACT_NAVIGATION_DEVTOOLS = new WeakMap();
/**
 * Container component which holds the navigation state designed for React Native apps.
 * This should be rendered at the root wrapping the whole app.
 *
 * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).
 * @param props.onReady Callback which is called after the navigation tree mounts.
 * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
 * @param props.theme Theme object for the navigators.
 * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.
 * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.
 * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.
 * @param props.children Child elements to render the content.
 * @param props.ref Ref object which refers to the navigation object containing helper methods.
 */ function NavigationContainerInner(_param, ref) {
    var _param_theme = _param.theme, theme = _param_theme === void 0 ? _DefaultTheme.default : _param_theme, linking = _param.linking, _param_fallback = _param.fallback, fallback = _param_fallback === void 0 ? null : _param_fallback, documentTitle = _param.documentTitle, onReady = _param.onReady, rest = _object_without_properties._(_param, [
        "theme",
        "linking",
        "fallback",
        "documentTitle",
        "onReady"
    ]);
    var isLinkingEnabled = linking ? linking.enabled !== false : false;
    if (linking === null || linking === void 0 ? void 0 : linking.config) {
        (0, _core.validatePathConfig)(linking.config);
    }
    var refContainer = _react.useRef(null);
    (0, _useBackButton.default)(refContainer);
    (0, _useDocumentTitle.default)(refContainer, documentTitle);
    var getInitialState = (0, _useLinking.default)(refContainer, _object_spread._({
        independent: rest.independent,
        enabled: isLinkingEnabled,
        prefixes: []
    }, linking)).getInitialState;
    // Add additional linking related info to the ref
    // This will be used by the devtools
    _react.useEffect(()=>{
        if (refContainer.current) {
            REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {
                get linking () {
                    return _object_spread_props._(_object_spread._({}, linking), {
                        enabled: isLinkingEnabled,
                        prefixes: (linking === null || linking === void 0 ? void 0 : linking.prefixes) ?? [],
                        getStateFromPath: (linking === null || linking === void 0 ? void 0 : linking.getStateFromPath) ?? _core.getStateFromPath,
                        getPathFromState: (linking === null || linking === void 0 ? void 0 : linking.getPathFromState) ?? _core.getPathFromState,
                        getActionFromState: (linking === null || linking === void 0 ? void 0 : linking.getActionFromState) ?? _core.getActionFromState
                    });
                }
            });
        }
    });
    var _useThenable1 = _sliced_to_array._((0, _useThenable.default)(getInitialState), 2), isResolved = _useThenable1[0], initialState = _useThenable1[1];
    _react.useImperativeHandle(ref, ()=>refContainer.current);
    var linkingContext = _react.useMemo(()=>({
            options: linking
        }), [
        linking
    ]);
    var isReady = rest.initialState != null || !isLinkingEnabled || isResolved;
    var onReadyRef = _react.useRef(onReady);
    _react.useEffect(()=>{
        onReadyRef.current = onReady;
    });
    _react.useEffect(()=>{
        if (isReady) {
            var _onReadyRef_current;
            (_onReadyRef_current = onReadyRef.current) === null || _onReadyRef_current === void 0 ? void 0 : _onReadyRef_current.call(onReadyRef);
        }
    }, [
        isReady
    ]);
    if (!isReady) {
        // This is temporary until we have Suspense for data-fetching
        // Then the fallback will be handled by a parent `Suspense` component
        return fallback;
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_LinkingContext.default.Provider, {
        value: linkingContext,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_ThemeProvider.default, {
            value: theme,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_core.BaseNavigationContainer, _object_spread_props._(_object_spread._({}, rest), {
                initialState: rest.initialState == null ? initialState : rest.initialState,
                ref: refContainer
            }))
        })
    });
}
var NavigationContainer = /*#__PURE__*/ _react.forwardRef(NavigationContainerInner);
var _default = NavigationContainer;


}),
55619: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _jsxruntime = __webpack_require__(53083);
var _core = __webpack_require__(39511);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _ServerContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(38785));
var _default = /*#__PURE__*/ _react.forwardRef(function ServerContainer(ref, ref1) {
    var children = ref.children, location = ref.location;
    _react.useEffect(()=>{
        console.error("'ServerContainer' should only be used on the server with 'react-dom/server' for SSR.");
    }, []);
    var current = {};
    if (ref1) {
        var value = {
            getCurrentOptions () {
                return current.options;
            }
        };
        // We write to the `ref` during render instead of `React.useImperativeHandle`
        // This is because `useImperativeHandle` will update the ref after 'commit',
        // and there's no 'commit' phase during SSR.
        // Mutating ref during render is unsafe in concurrent mode, but we don't care about it for SSR.
        if (typeof ref1 === 'function') {
            ref1(value);
        } else {
            // @ts-expect-error: the TS types are incorrect and say that ref.current is readonly
            ref1.current = value;
        }
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_ServerContext.default.Provider, {
        value: {
            location
        },
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_core.CurrentRenderContext.Provider, {
            value: current,
            children: children
        })
    });
});


}),
38785: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var ServerContext = /*#__PURE__*/ _react.createContext(undefined);
var _default = ServerContext;


}),
37964: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return extractPathFromURL;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _sliced_to_array = __webpack_require__(30067);
var _escapestringregexp = /*#__PURE__*/ _interop_require_default._(__webpack_require__(87695));
function extractPathFromURL(prefixes, url) {
    for (var prefix of prefixes){
        var _prefix_match;
        var protocol = ((_prefix_match = prefix.match(/^[^:]+:/)) === null || _prefix_match === void 0 ? void 0 : _prefix_match[0]) ?? '';
        var host = prefix.replace(new RegExp(`^${(0, _escapestringregexp.default)(protocol)}`), '').replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
        .replace(/^\//, ''); // Remove extra leading slash
        var prefixRegex = new RegExp(`^${(0, _escapestringregexp.default)(protocol)}(/)*${host.split('.').map((it)=>it === '*' ? '[^/]+' : (0, _escapestringregexp.default)(it)).join('\\.')}`);
        var _url_split = _sliced_to_array._(url.split('?'), 2), originAndPath = _url_split[0], searchParams = _url_split[1];
        var normalizedURL = originAndPath.replace(/\/+/g, '/').concat(searchParams ? `?${searchParams}` : '');
        if (prefixRegex.test(normalizedURL)) {
            return normalizedURL.replace(prefixRegex, '');
        }
    }
    return undefined;
}


}),
74722: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get DarkTheme () {
        return _DarkTheme.default;
    },
    get DefaultTheme () {
        return _DefaultTheme.default;
    },
    get Link () {
        return _Link.default;
    },
    get LinkingContext () {
        return _LinkingContext.default;
    },
    get NavigationContainer () {
        return _NavigationContainer.default;
    },
    get ServerContainer () {
        return _ServerContainer.default;
    },
    get ThemeProvider () {
        return _ThemeProvider.default;
    },
    get useLinkBuilder () {
        return _useLinkBuilder.default;
    },
    get useLinkProps () {
        return _useLinkProps.default;
    },
    get useLinkTo () {
        return _useLinkTo.default;
    },
    get useScrollToTop () {
        return _useScrollToTop.default;
    },
    get useTheme () {
        return _useTheme.default;
    }
});
var _export_star = __webpack_require__(80010);
var _interop_require_default = __webpack_require__(92766);
var _Link = /*#__PURE__*/ _interop_require_default._(__webpack_require__(68798));
var _LinkingContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27996));
var _NavigationContainer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(54523));
var _ServerContainer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(55619));
var _DarkTheme = /*#__PURE__*/ _interop_require_default._(__webpack_require__(97779));
var _DefaultTheme = /*#__PURE__*/ _interop_require_default._(__webpack_require__(41041));
var _ThemeProvider = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8299));
var _useTheme = /*#__PURE__*/ _interop_require_default._(__webpack_require__(29356));
_export_star._(__webpack_require__(32788), exports);
var _useLinkBuilder = /*#__PURE__*/ _interop_require_default._(__webpack_require__(13045));
var _useLinkProps = /*#__PURE__*/ _interop_require_default._(__webpack_require__(24553));
var _useLinkTo = /*#__PURE__*/ _interop_require_default._(__webpack_require__(51706));
var _useScrollToTop = /*#__PURE__*/ _interop_require_default._(__webpack_require__(59029));
_export_star._(__webpack_require__(39511), exports);


}),
97779: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var DarkTheme = {
    dark: true,
    colors: {
        primary: 'rgb(10, 132, 255)',
        background: 'rgb(1, 1, 1)',
        card: 'rgb(18, 18, 18)',
        text: 'rgb(229, 229, 231)',
        border: 'rgb(39, 39, 41)',
        notification: 'rgb(255, 69, 58)'
    }
};
var _default = DarkTheme;


}),
41041: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var DefaultTheme = {
    dark: false,
    colors: {
        primary: 'rgb(0, 122, 255)',
        background: 'rgb(242, 242, 242)',
        card: 'rgb(255, 255, 255)',
        text: 'rgb(28, 28, 30)',
        border: 'rgb(216, 216, 216)',
        notification: 'rgb(255, 59, 48)'
    }
};
var _default = DefaultTheme;


}),
98189: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _DefaultTheme = /*#__PURE__*/ _interop_require_default._(__webpack_require__(41041));
var ThemeContext = /*#__PURE__*/ _react.createContext(_DefaultTheme.default);
ThemeContext.displayName = 'ThemeContext';
var _default = ThemeContext;


}),
8299: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return ThemeProvider;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _jsxruntime = __webpack_require__(53083);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _ThemeContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98189));
function ThemeProvider(ref) {
    var value = ref.value, children = ref.children;
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_ThemeContext.default.Provider, {
        value: value,
        children: children
    });
}


}),
29356: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useTheme;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _ThemeContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(98189));
function useTheme() {
    var theme = _react.useContext(_ThemeContext.default);
    return theme;
}


}),
32788: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));


}),
90210: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useBackButton;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _reactnative = __webpack_require__(1350);
function useBackButton(ref) {
    _react.useEffect(()=>{
        var subscription = _reactnative.BackHandler.addEventListener('hardwareBackPress', ()=>{
            var navigation = ref.current;
            if (navigation == null) {
                return false;
            }
            if (navigation.canGoBack()) {
                navigation.goBack();
                return true;
            }
            return false;
        });
        return ()=>subscription.remove();
    }, [
        ref
    ]);
}


}),
5788: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useDocumentTitle;
    }
}));
function useDocumentTitle() {
// Noop for React Native
}


}),
13045: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useLinkBuilder;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _core = __webpack_require__(39511);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _LinkingContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27996));
var getRootStateForNavigate = (navigation, state)=>{
    var parent = navigation.getParent();
    if (parent) {
        var parentState = parent.getState();
        return getRootStateForNavigate(parent, {
            index: 0,
            routes: [
                _object_spread_props._(_object_spread._({}, parentState.routes[parentState.index]), {
                    state: state
                })
            ]
        });
    }
    return state;
};
function useLinkBuilder() {
    var navigation = _react.useContext(_core.NavigationHelpersContext);
    var linking = _react.useContext(_LinkingContext.default);
    var buildLink = _react.useCallback((name, params)=>{
        var options = linking.options;
        if ((options === null || options === void 0 ? void 0 : options.enabled) === false) {
            return undefined;
        }
        var state = navigation ? getRootStateForNavigate(navigation, {
            index: 0,
            routes: [
                {
                    name,
                    params
                }
            ]
        }) : // So we'll construct a basic state object to use
        {
            index: 0,
            routes: [
                {
                    name,
                    params
                }
            ]
        };
        var path = (options === null || options === void 0 ? void 0 : options.getPathFromState) ? options.getPathFromState(state, options === null || options === void 0 ? void 0 : options.config) : (0, _core.getPathFromState)(state, options === null || options === void 0 ? void 0 : options.config);
        return path;
    }, [
        linking,
        navigation
    ]);
    return buildLink;
}


}),
24553: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useLinkProps;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _core = __webpack_require__(39511);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _reactnative = __webpack_require__(1350);
var _LinkingContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27996));
var _useLinkTo = /*#__PURE__*/ _interop_require_default._(__webpack_require__(51706));
var getStateFromParams = (params)=>{
    if (params === null || params === void 0 ? void 0 : params.state) {
        return params.state;
    }
    if (params === null || params === void 0 ? void 0 : params.screen) {
        return {
            routes: [
                {
                    name: params.screen,
                    params: params.params,
                    // @ts-expect-error
                    state: params.screen ? getStateFromParams(params.params) : undefined
                }
            ]
        };
    }
    return undefined;
};
function useLinkProps(ref) {
    var to = ref.to, action = ref.action;
    var root = _react.useContext(_core.NavigationContainerRefContext);
    var navigation = _react.useContext(_core.NavigationHelpersContext);
    var options = _react.useContext(_LinkingContext.default).options;
    var linkTo = (0, _useLinkTo.default)();
    var onPress = (e)=>{
        var _e_currentTarget;
        var shouldHandle = false;
        if (_reactnative.Platform.OS !== 'web' || !e) {
            shouldHandle = e ? !e.defaultPrevented : true;
        } else if (!e.defaultPrevented && // onPress prevented default
        // @ts-expect-error: these properties exist on web, but not in React Native
        !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && // ignore clicks with modifier keys
        // @ts-expect-error: these properties exist on web, but not in React Native
        (e.button == null || e.button === 0) && // ignore everything but left clicks
        // @ts-expect-error: these properties exist on web, but not in React Native
        [
            undefined,
            null,
            '',
            'self'
        ].includes((_e_currentTarget = e.currentTarget) === null || _e_currentTarget === void 0 ? void 0 : _e_currentTarget.target) // let browser handle "target=_blank" etc.
        ) {
            e.preventDefault();
            shouldHandle = true;
        }
        if (shouldHandle) {
            if (action) {
                if (navigation) {
                    navigation.dispatch(action);
                } else if (root) {
                    root.dispatch(action);
                } else {
                    throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
                }
            } else {
                linkTo(to);
            }
        }
    };
    var getPathFromStateHelper = (options === null || options === void 0 ? void 0 : options.getPathFromState) ?? _core.getPathFromState;
    var href = typeof to === 'string' ? to : getPathFromStateHelper({
        routes: [
            {
                name: to.screen,
                // @ts-expect-error
                params: to.params,
                // @ts-expect-error
                state: getStateFromParams(to.params)
            }
        ]
    }, options === null || options === void 0 ? void 0 : options.config);
    return {
        href,
        accessibilityRole: 'link',
        onPress
    };
}


}),
51706: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useLinkTo;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _core = __webpack_require__(39511);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _LinkingContext = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27996));
function useLinkTo() {
    var navigation = _react.useContext(_core.NavigationContainerRefContext);
    var linking = _react.useContext(_LinkingContext.default);
    var linkTo = _react.useCallback((to)=>{
        if (navigation === undefined) {
            throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
        }
        if (typeof to !== 'string') {
            // @ts-expect-error: This is fine
            navigation.navigate(to.screen, to.params);
            return;
        }
        if (!to.startsWith('/')) {
            throw new Error(`The path must start with '/' (${to}).`);
        }
        var options = linking.options;
        var state = (options === null || options === void 0 ? void 0 : options.getStateFromPath) ? options.getStateFromPath(to, options.config) : (0, _core.getStateFromPath)(to, options === null || options === void 0 ? void 0 : options.config);
        if (state) {
            var action = (0, _core.getActionFromState)(state, options === null || options === void 0 ? void 0 : options.config);
            if (action !== undefined) {
                navigation.dispatch(action);
            } else {
                navigation.reset(state);
            }
        } else {
            throw new Error('Failed to parse the path to a navigation state.');
        }
    }, [
        linking,
        navigation
    ]);
    return linkTo;
}


}),
83562: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useLinking;
    }
}));
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _core = __webpack_require__(39511);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
var _reactnative = __webpack_require__(1350);
var _extractPathFromURL = /*#__PURE__*/ _interop_require_default._(__webpack_require__(37964));
var linkingHandlers = [];
function useLinking(ref, ref1) {
    var independent = ref1.independent, _ref_enabled = ref1.enabled, enabled = _ref_enabled === void 0 ? true : _ref_enabled, prefixes = ref1.prefixes, filter = ref1.filter, config = ref1.config, _ref_getInitialURL = ref1.getInitialURL, getInitialURL = _ref_getInitialURL === void 0 ? ()=>Promise.race([
            _reactnative.Linking.getInitialURL(),
            new Promise((resolve)=>// Timeout in 150ms if `getInitialState` doesn't resolve
                // Workaround for https://github.com/facebook/react-native/issues/25675
                setTimeout(resolve, 150))
        ]) : _ref_getInitialURL, _ref_subscribe = ref1.subscribe, subscribe = _ref_subscribe === void 0 ? (listener)=>{
        var _Linking_removeEventListener;
        var callback = (ref)=>{
            var url = ref.url;
            return listener(url);
        };
        var subscription = _reactnative.Linking.addEventListener('url', callback);
        // Storing this in a local variable stops Jest from complaining about import after teardown
        // @ts-expect-error: removeEventListener is not present in newer RN versions
        var removeEventListener = (_Linking_removeEventListener = _reactnative.Linking.removeEventListener) === null || _Linking_removeEventListener === void 0 ? void 0 : _Linking_removeEventListener.bind(_reactnative.Linking);
        return ()=>{
            // https://github.com/facebook/react-native/commit/6d1aca806cee86ad76de771ed3a1cc62982ebcd7
            if (subscription === null || subscription === void 0 ? void 0 : subscription.remove) {
                subscription.remove();
            } else {
                removeEventListener === null || removeEventListener === void 0 ? void 0 : removeEventListener('url', callback);
            }
        };
    } : _ref_subscribe, _ref_getStateFromPath = ref1.getStateFromPath, getStateFromPath = _ref_getStateFromPath === void 0 ? _core.getStateFromPath : _ref_getStateFromPath, _ref_getActionFromState = ref1.getActionFromState, getActionFromState = _ref_getActionFromState === void 0 ? _core.getActionFromState : _ref_getActionFromState;
    _react.useEffect(()=>{
        if (true) {
            return undefined;
        }
        if (independent) {
            return undefined;
        }
        if (enabled !== false && linkingHandlers.length) {
            console.error([
                'Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:',
                "- You don't have multiple NavigationContainers in the app each with 'linking' enabled",
                '- Only a single instance of the root component is rendered',
                _reactnative.Platform.OS === 'android' ? "- You have set 'android:launchMode=singleTask' in the '<activity />' section of the 'AndroidManifest.xml' file to avoid launching multiple instances" : ''
            ].join('\n').trim());
        }
        var handler = Symbol();
        if (enabled !== false) {
            linkingHandlers.push(handler);
        }
        return ()=>{
            var index = linkingHandlers.indexOf(handler);
            if (index > -1) {
                linkingHandlers.splice(index, 1);
            }
        };
    }, [
        enabled,
        independent
    ]);
    // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners
    // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`
    // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect
    var enabledRef = _react.useRef(enabled);
    var prefixesRef = _react.useRef(prefixes);
    var filterRef = _react.useRef(filter);
    var configRef = _react.useRef(config);
    var getInitialURLRef = _react.useRef(getInitialURL);
    var getStateFromPathRef = _react.useRef(getStateFromPath);
    var getActionFromStateRef = _react.useRef(getActionFromState);
    _react.useEffect(()=>{
        enabledRef.current = enabled;
        prefixesRef.current = prefixes;
        filterRef.current = filter;
        configRef.current = config;
        getInitialURLRef.current = getInitialURL;
        getStateFromPathRef.current = getStateFromPath;
        getActionFromStateRef.current = getActionFromState;
    });
    var getStateFromURL = _react.useCallback((url)=>{
        if (!url || filterRef.current && !filterRef.current(url)) {
            return undefined;
        }
        var path = (0, _extractPathFromURL.default)(prefixesRef.current, url);
        return path !== undefined ? getStateFromPathRef.current(path, configRef.current) : undefined;
    }, []);
    var getInitialState = _react.useCallback(()=>{
        var state;
        if (enabledRef.current) {
            var url = getInitialURLRef.current();
            if (url != null && typeof url !== 'string') {
                return url.then((url)=>{
                    var state = getStateFromURL(url);
                    return state;
                });
            }
            state = getStateFromURL(url);
        }
        var thenable = {
            then (onfulfilled) {
                return Promise.resolve(onfulfilled ? onfulfilled(state) : state);
            },
            catch () {
                return thenable;
            }
        };
        return thenable;
    }, [
        getStateFromURL
    ]);
    _react.useEffect(()=>{
        var listener = (url)=>{
            if (!enabled) {
                return;
            }
            var navigation = ref.current;
            var state = navigation ? getStateFromURL(url) : undefined;
            if (navigation && state) {
                // Make sure that the routes in the state exist in the root navigator
                // Otherwise there's an error in the linking configuration
                var rootState = navigation.getRootState();
                if (state.routes.some((r)=>!(rootState === null || rootState === void 0 ? void 0 : rootState.routeNames.includes(r.name)))) {
                    console.warn("The navigation state parsed from the URL contains routes not present in the root navigator. This usually means that the linking configuration doesn't match the navigation structure. See https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.");
                    return;
                }
                var action = getActionFromStateRef.current(state, configRef.current);
                if (action !== undefined) {
                    try {
                        navigation.dispatch(action);
                    } catch (e) {
                        // Ignore any errors from deep linking.
                        // This could happen in case of malformed links, navigation object not being initialized etc.
                        console.warn(`An error occurred when trying to handle the link '${url}': ${typeof e === 'object' && e != null && 'message' in e ? e.message : e}`);
                    }
                } else {
                    navigation.resetRoot(state);
                }
            }
        };
        return subscribe(listener);
    }, [
        enabled,
        getStateFromURL,
        ref,
        subscribe
    ]);
    return {
        getInitialState
    };
}


}),
59029: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useScrollToTop;
    }
}));
var _interop_require_wildcard = __webpack_require__(97427);
var _core = __webpack_require__(39511);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
function getScrollableNode(ref) {
    if (ref.current == null) {
        return null;
    }
    if ('scrollToTop' in ref.current || 'scrollTo' in ref.current || 'scrollToOffset' in ref.current || 'scrollResponderScrollTo' in ref.current) {
        // This is already a scrollable node.
        return ref.current;
    } else if ('getScrollResponder' in ref.current) {
        // If the view is a wrapper like FlatList, SectionList etc.
        // We need to use `getScrollResponder` to get access to the scroll responder
        return ref.current.getScrollResponder();
    } else if ('getNode' in ref.current) {
        // When a `ScrollView` is wraped in `Animated.createAnimatedComponent`
        // we need to use `getNode` to get the ref to the actual scrollview.
        // Note that `getNode` is deprecated in newer versions of react-native
        // this is why we check if we already have a scrollable node above.
        return ref.current.getNode();
    } else {
        return ref.current;
    }
}
function useScrollToTop(ref) {
    var navigation = _react.useContext(_core.NavigationContext);
    var route = (0, _core.useRoute)();
    if (navigation === undefined) {
        throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    _react.useEffect(()=>{
        var tabNavigations = [];
        var currentNavigation = navigation;
        // If the screen is nested inside multiple tab navigators, we should scroll to top for any of them
        // So we need to find all the parent tab navigators and add the listeners there
        while(currentNavigation){
            if (currentNavigation.getState().type === 'tab') {
                tabNavigations.push(currentNavigation);
            }
            currentNavigation = currentNavigation.getParent();
        }
        if (tabNavigations.length === 0) {
            return;
        }
        var unsubscribers = tabNavigations.map((tab)=>{
            return tab.addListener(// We don't wanna import tab types here to avoid extra deps
            // in addition, there are multiple tab implementations
            // @ts-expect-error
            'tabPress', (e)=>{
                // We should scroll to top only when the screen is focused
                var isFocused = navigation.isFocused();
                // In a nested stack navigator, tab press resets the stack to first screen
                // So we should scroll to top only when we are on first screen
                var isFirst = tabNavigations.includes(navigation) || navigation.getState().routes[0].key === route.key;
                // Run the operation in the next frame so we're sure all listeners have been run
                // This is necessary to know if preventDefault() has been called
                requestAnimationFrame(()=>{
                    var scrollable = getScrollableNode(ref);
                    if (isFocused && isFirst && scrollable && !e.defaultPrevented) {
                        if ('scrollToTop' in scrollable) {
                            scrollable.scrollToTop();
                        } else if ('scrollTo' in scrollable) {
                            scrollable.scrollTo({
                                y: 0,
                                animated: true
                            });
                        } else if ('scrollToOffset' in scrollable) {
                            scrollable.scrollToOffset({
                                offset: 0,
                                animated: true
                            });
                        } else if ('scrollResponderScrollTo' in scrollable) {
                            scrollable.scrollResponderScrollTo({
                                y: 0,
                                animated: true
                            });
                        }
                    }
                });
            });
        });
        return ()=>{
            unsubscribers.forEach((unsubscribe)=>unsubscribe());
        };
    }, [
        navigation,
        ref,
        route.key
    ]);
}


}),
51490: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return useThenable;
    }
}));
var _async_to_generator = __webpack_require__(70185);
var _interop_require_wildcard = __webpack_require__(97427);
var _sliced_to_array = __webpack_require__(30067);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(13668));
function useThenable(create) {
    var _React_useState = _sliced_to_array._(_react.useState(create), 1), promise = _React_useState[0];
    var initialState = [
        false,
        undefined
    ];
    // Check if our thenable is synchronous
    promise.then((result)=>{
        initialState = [
            true,
            result
        ];
    });
    var _React_useState1 = _sliced_to_array._(_react.useState(initialState), 2), state = _React_useState1[0], setState = _React_useState1[1];
    var _state = _sliced_to_array._(state, 1), resolved = _state[0];
    _react.useEffect(()=>{
        var cancelled = false;
        var resolve = ()=>_async_to_generator._(function*() {
                var result;
                try {
                    result = yield promise;
                } finally{
                    if (!cancelled) {
                        setState([
                            true,
                            result
                        ]);
                    }
                }
            })();
        if (!resolved) {
            resolve();
        }
        return ()=>{
            cancelled = true;
        };
    }, [
        promise,
        resolved
    ]);
    return state;
}


}),
8101: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _nonsecure = __webpack_require__(15771);
/**
 * Base router object that can be used when writing custom routers.
 * This provides few helper methods to handle common actions such as `RESET`.
 */ var BaseRouter = {
    getStateForAction (state, action) {
        switch(action.type){
            case 'SET_PARAMS':
                {
                    var index = action.source ? state.routes.findIndex((r)=>r.key === action.source) : state.index;
                    if (index === -1) {
                        return null;
                    }
                    return _object_spread_props._(_object_spread._({}, state), {
                        routes: state.routes.map((r, i)=>i === index ? _object_spread_props._(_object_spread._({}, r), {
                                params: _object_spread._({}, r.params, action.payload.params)
                            }) : r)
                    });
                }
            case 'RESET':
                {
                    var nextState = action.payload;
                    if (nextState.routes.length === 0 || nextState.routes.some((route)=>!state.routeNames.includes(route.name))) {
                        return null;
                    }
                    if (nextState.stale === false) {
                        if (state.routeNames.length !== nextState.routeNames.length || nextState.routeNames.some((name)=>!state.routeNames.includes(name))) {
                            return null;
                        }
                        return _object_spread_props._(_object_spread._({}, nextState), {
                            routes: nextState.routes.map((route)=>route.key ? route : _object_spread_props._(_object_spread._({}, route), {
                                    key: `${route.name}-${(0, _nonsecure.nanoid)()}`
                                }))
                        });
                    }
                    return nextState;
                }
            default:
                return null;
        }
    },
    shouldActionChangeFocus (action) {
        return action.type === 'NAVIGATE';
    }
};
var _default = BaseRouter;


}),
60106: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get goBack () {
        return goBack;
    },
    get navigate () {
        return navigate;
    },
    get reset () {
        return reset;
    },
    get setParams () {
        return setParams;
    }
});
function goBack() {
    return {
        type: 'GO_BACK'
    };
}
function navigate(...args) {
    if (typeof args[0] === 'string') {
        return {
            type: 'NAVIGATE',
            payload: {
                name: args[0],
                params: args[1]
            }
        };
    } else {
        var payload = args[0] || {};
        if (!payload.hasOwnProperty('key') && !payload.hasOwnProperty('name')) {
            throw new Error('You need to specify name or key when calling navigate with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigate for usage.');
        }
        return {
            type: 'NAVIGATE',
            payload
        };
    }
}
function reset(state) {
    return {
        type: 'RESET',
        payload: state
    };
}
function setParams(params) {
    return {
        type: 'SET_PARAMS',
        payload: {
            params
        }
    };
}


}),
36127: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get DrawerActions () {
        return DrawerActions;
    },
    get default () {
        return DrawerRouter;
    }
});
var _interop_require_wildcard = __webpack_require__(97427);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _object_without_properties = __webpack_require__(67334);
var _to_consumable_array = __webpack_require__(60116);
var _nonsecure = __webpack_require__(15771);
var _TabRouter = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(16449));
var DrawerActions = _object_spread_props._(_object_spread._({}, _TabRouter.TabActions), {
    openDrawer () {
        return {
            type: 'OPEN_DRAWER'
        };
    },
    closeDrawer () {
        return {
            type: 'CLOSE_DRAWER'
        };
    },
    toggleDrawer () {
        return {
            type: 'TOGGLE_DRAWER'
        };
    }
});
function DrawerRouter(_param) {
    var _param_defaultStatus = _param.defaultStatus, defaultStatus = _param_defaultStatus === void 0 ? 'closed' : _param_defaultStatus, rest = _object_without_properties._(_param, [
        "defaultStatus"
    ]);
    var router = (0, _TabRouter.default)(rest);
    var isDrawerInHistory = (state)=>{
        var _state_history;
        return Boolean((_state_history = state.history) === null || _state_history === void 0 ? void 0 : _state_history.some((it)=>it.type === 'drawer'));
    };
    var addDrawerToHistory = (state)=>{
        if (isDrawerInHistory(state)) {
            return state;
        }
        return _object_spread_props._(_object_spread._({}, state), {
            history: _to_consumable_array._(state.history).concat([
                {
                    type: 'drawer',
                    status: defaultStatus === 'open' ? 'closed' : 'open'
                }
            ])
        });
    };
    var removeDrawerFromHistory = (state)=>{
        if (!isDrawerInHistory(state)) {
            return state;
        }
        return _object_spread_props._(_object_spread._({}, state), {
            history: state.history.filter((it)=>it.type !== 'drawer')
        });
    };
    var openDrawer = (state)=>{
        if (defaultStatus === 'open') {
            return removeDrawerFromHistory(state);
        }
        return addDrawerToHistory(state);
    };
    var closeDrawer = (state)=>{
        if (defaultStatus === 'open') {
            return addDrawerToHistory(state);
        }
        return removeDrawerFromHistory(state);
    };
    return _object_spread_props._(_object_spread._({}, router), {
        type: 'drawer',
        getInitialState (ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeGetIdList = ref.routeGetIdList;
            var state = router.getInitialState({
                routeNames,
                routeParamList,
                routeGetIdList
            });
            return _object_spread_props._(_object_spread._({}, state), {
                default: defaultStatus,
                stale: false,
                type: 'drawer',
                key: `drawer-${(0, _nonsecure.nanoid)()}`
            });
        },
        getRehydratedState (partialState, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeGetIdList = ref.routeGetIdList;
            if (partialState.stale === false) {
                return partialState;
            }
            var state = router.getRehydratedState(partialState, {
                routeNames,
                routeParamList,
                routeGetIdList
            });
            if (isDrawerInHistory(partialState)) {
                // Re-sync the drawer entry in history to correct it if it was wrong
                state = removeDrawerFromHistory(state);
                state = addDrawerToHistory(state);
            }
            return _object_spread_props._(_object_spread._({}, state), {
                default: defaultStatus,
                type: 'drawer',
                key: `drawer-${(0, _nonsecure.nanoid)()}`
            });
        },
        getStateForRouteFocus (state, key) {
            var result = router.getStateForRouteFocus(state, key);
            return closeDrawer(result);
        },
        getStateForAction (state, action, options) {
            switch(action.type){
                case 'OPEN_DRAWER':
                    return openDrawer(state);
                case 'CLOSE_DRAWER':
                    return closeDrawer(state);
                case 'TOGGLE_DRAWER':
                    if (isDrawerInHistory(state)) {
                        return removeDrawerFromHistory(state);
                    }
                    return addDrawerToHistory(state);
                case 'JUMP_TO':
                case 'NAVIGATE':
                    {
                        var result = router.getStateForAction(state, action, options);
                        if (result != null && result.index !== state.index) {
                            return closeDrawer(result);
                        }
                        return result;
                    }
                case 'GO_BACK':
                    if (isDrawerInHistory(state)) {
                        return removeDrawerFromHistory(state);
                    }
                    return router.getStateForAction(state, action, options);
                default:
                    return router.getStateForAction(state, action, options);
            }
        },
        actionCreators: DrawerActions
    });
}


}),
32734: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get StackActions () {
        return StackActions;
    },
    get default () {
        return StackRouter;
    }
});
var _interop_require_default = __webpack_require__(92766);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _to_consumable_array = __webpack_require__(60116);
var _nonsecure = __webpack_require__(15771);
var _BaseRouter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8101));
var StackActions = {
    replace (name, params) {
        return {
            type: 'REPLACE',
            payload: {
                name,
                params
            }
        };
    },
    push (name, params) {
        return {
            type: 'PUSH',
            payload: {
                name,
                params
            }
        };
    },
    pop (ref) {
        var count = ref === void 0 ? 1 : ref;
        return {
            type: 'POP',
            payload: {
                count
            }
        };
    },
    popToTop () {
        return {
            type: 'POP_TO_TOP'
        };
    }
};
function StackRouter(options) {
    var router = _object_spread_props._(_object_spread._({}, _BaseRouter.default), {
        type: 'stack',
        getInitialState (ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
            return {
                stale: false,
                type: 'stack',
                key: `stack-${(0, _nonsecure.nanoid)()}`,
                index: 0,
                routeNames,
                routes: [
                    {
                        key: `${initialRouteName}-${(0, _nonsecure.nanoid)()}`,
                        name: initialRouteName,
                        params: routeParamList[initialRouteName]
                    }
                ]
            };
        },
        getRehydratedState (partialState, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var state = partialState;
            if (state.stale === false) {
                return state;
            }
            var routes = state.routes.filter((route)=>routeNames.includes(route.name)).map((route)=>_object_spread_props._(_object_spread._({}, route), {
                    key: route.key || `${route.name}-${(0, _nonsecure.nanoid)()}`,
                    params: routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], route.params) : route.params
                }));
            if (routes.length === 0) {
                var initialRouteName = options.initialRouteName !== undefined ? options.initialRouteName : routeNames[0];
                routes.push({
                    key: `${initialRouteName}-${(0, _nonsecure.nanoid)()}`,
                    name: initialRouteName,
                    params: routeParamList[initialRouteName]
                });
            }
            return {
                stale: false,
                type: 'stack',
                key: `stack-${(0, _nonsecure.nanoid)()}`,
                index: routes.length - 1,
                routeNames,
                routes
            };
        },
        getStateForRouteNamesChange (state, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeKeyChanges = ref.routeKeyChanges;
            var routes = state.routes.filter((route)=>routeNames.includes(route.name) && !routeKeyChanges.includes(route.name));
            if (routes.length === 0) {
                var initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
                routes.push({
                    key: `${initialRouteName}-${(0, _nonsecure.nanoid)()}`,
                    name: initialRouteName,
                    params: routeParamList[initialRouteName]
                });
            }
            return _object_spread_props._(_object_spread._({}, state), {
                routeNames,
                routes,
                index: Math.min(state.index, routes.length - 1)
            });
        },
        getStateForRouteFocus (state, key) {
            var index = state.routes.findIndex((r)=>r.key === key);
            if (index === -1 || index === state.index) {
                return state;
            }
            return _object_spread_props._(_object_spread._({}, state), {
                index,
                routes: state.routes.slice(0, index + 1)
            });
        },
        getStateForAction (state, action, options) {
            var routeParamList = options.routeParamList;
            switch(action.type){
                case 'REPLACE':
                    {
                        var index = action.target === state.key && action.source ? state.routes.findIndex((r)=>r.key === action.source) : state.index;
                        if (index === -1) {
                            return null;
                        }
                        var _action_payload = action.payload, name = _action_payload.name, key = _action_payload.key, params = _action_payload.params;
                        if (!state.routeNames.includes(name)) {
                            return null;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            routes: state.routes.map((route, i)=>i === index ? {
                                    key: key !== undefined ? key : `${name}-${(0, _nonsecure.nanoid)()}`,
                                    name,
                                    params: routeParamList[name] !== undefined ? _object_spread._({}, routeParamList[name], params) : params
                                } : route)
                        });
                    }
                case 'PUSH':
                    if (state.routeNames.includes(action.payload.name)) {
                        var getId = options.routeGetIdList[action.payload.name];
                        var id = getId === null || getId === void 0 ? void 0 : getId({
                            params: action.payload.params
                        });
                        var route = id ? state.routes.find((route)=>route.name === action.payload.name && id === (getId === null || getId === void 0 ? void 0 : getId({
                                params: route.params
                            }))) : undefined;
                        var routes;
                        if (route) {
                            routes = state.routes.filter((r)=>r.key !== route.key);
                            routes.push(_object_spread_props._(_object_spread._({}, route), {
                                params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                            }));
                        } else {
                            routes = _to_consumable_array._(state.routes).concat([
                                {
                                    key: `${action.payload.name}-${(0, _nonsecure.nanoid)()}`,
                                    name: action.payload.name,
                                    params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                                }
                            ]);
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            index: routes.length - 1,
                            routes
                        });
                    }
                    return null;
                case 'POP':
                    {
                        var index1 = action.target === state.key && action.source ? state.routes.findIndex((r)=>r.key === action.source) : state.index;
                        if (index1 > 0) {
                            var count = Math.max(index1 - action.payload.count + 1, 1);
                            var routes1 = state.routes.slice(0, count).concat(state.routes.slice(index1 + 1));
                            return _object_spread_props._(_object_spread._({}, state), {
                                index: routes1.length - 1,
                                routes: routes1
                            });
                        }
                        return null;
                    }
                case 'POP_TO_TOP':
                    return router.getStateForAction(state, {
                        type: 'POP',
                        payload: {
                            count: state.routes.length - 1
                        }
                    }, options);
                case 'NAVIGATE':
                    if (action.payload.name !== undefined && !state.routeNames.includes(action.payload.name)) {
                        return null;
                    }
                    if (action.payload.key || action.payload.name) {
                        // If the route already exists, navigate to that
                        var index2 = -1;
                        var getId1 = // `getId` and `key` can't be used together
                        action.payload.key === undefined && action.payload.name !== undefined ? options.routeGetIdList[action.payload.name] : undefined;
                        var id1 = getId1 === null || getId1 === void 0 ? void 0 : getId1({
                            params: action.payload.params
                        });
                        if (id1) {
                            index2 = state.routes.findIndex((route)=>route.name === action.payload.name && id1 === (getId1 === null || getId1 === void 0 ? void 0 : getId1({
                                    params: route.params
                                })));
                        } else if (state.routes[state.index].name === action.payload.name && action.payload.key === undefined || state.routes[state.index].key === action.payload.key) {
                            index2 = state.index;
                        } else {
                            for(var i = state.routes.length - 1; i >= 0; i--){
                                if (state.routes[i].name === action.payload.name && action.payload.key === undefined || state.routes[i].key === action.payload.key) {
                                    index2 = i;
                                    break;
                                }
                            }
                        }
                        if (index2 === -1 && action.payload.key && action.payload.name === undefined) {
                            return null;
                        }
                        if (index2 === -1 && action.payload.name !== undefined) {
                            var routes2 = _to_consumable_array._(state.routes).concat([
                                {
                                    key: action.payload.key ?? `${action.payload.name}-${(0, _nonsecure.nanoid)()}`,
                                    name: action.payload.name,
                                    path: action.payload.path,
                                    params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                                }
                            ]);
                            return _object_spread_props._(_object_spread._({}, state), {
                                routes: routes2,
                                index: routes2.length - 1
                            });
                        }
                        var route1 = state.routes[index2];
                        var params1;
                        if (action.payload.merge) {
                            params1 = action.payload.params !== undefined || routeParamList[route1.name] !== undefined ? _object_spread._({}, routeParamList[route1.name], route1.params, action.payload.params) : route1.params;
                        } else {
                            params1 = routeParamList[route1.name] !== undefined ? _object_spread._({}, routeParamList[route1.name], action.payload.params) : action.payload.params;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            index: index2,
                            routes: _to_consumable_array._(state.routes.slice(0, index2)).concat([
                                params1 !== route1.params || action.payload.path && action.payload.path !== route1.path ? _object_spread_props._(_object_spread._({}, route1), {
                                    path: action.payload.path ?? route1.path,
                                    params: params1
                                }) : state.routes[index2]
                            ])
                        });
                    }
                    return null;
                case 'GO_BACK':
                    if (state.index > 0) {
                        return router.getStateForAction(state, {
                            type: 'POP',
                            payload: {
                                count: 1
                            },
                            target: action.target,
                            source: action.source
                        }, options);
                    }
                    return null;
                default:
                    return _BaseRouter.default.getStateForAction(state, action);
            }
        },
        actionCreators: StackActions
    });
    return router;
}


}),
16449: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get TabActions () {
        return TabActions;
    },
    get default () {
        return TabRouter;
    }
});
var _interop_require_default = __webpack_require__(92766);
var _object_spread = __webpack_require__(40556);
var _object_spread_props = __webpack_require__(13919);
var _nonsecure = __webpack_require__(15771);
var _BaseRouter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8101));
var TYPE_ROUTE = 'route';
var TabActions = {
    jumpTo (name, params) {
        return {
            type: 'JUMP_TO',
            payload: {
                name,
                params
            }
        };
    }
};
var getRouteHistory = (routes, index, backBehavior, initialRouteName)=>{
    var history = [
        {
            type: TYPE_ROUTE,
            key: routes[index].key
        }
    ];
    var initialRouteIndex;
    switch(backBehavior){
        case 'order':
            for(var i = index; i > 0; i--){
                history.unshift({
                    type: TYPE_ROUTE,
                    key: routes[i - 1].key
                });
            }
            break;
        case 'firstRoute':
            if (index !== 0) {
                history.unshift({
                    type: TYPE_ROUTE,
                    key: routes[0].key
                });
            }
            break;
        case 'initialRoute':
            initialRouteIndex = routes.findIndex((route)=>route.name === initialRouteName);
            initialRouteIndex = initialRouteIndex === -1 ? 0 : initialRouteIndex;
            if (index !== initialRouteIndex) {
                history.unshift({
                    type: TYPE_ROUTE,
                    key: routes[initialRouteIndex].key
                });
            }
            break;
        case 'history':
            break;
    }
    return history;
};
var changeIndex = (state, index, backBehavior, initialRouteName)=>{
    var history;
    if (backBehavior === 'history') {
        var currentKey = state.routes[index].key;
        history = state.history.filter((it)=>it.type === 'route' ? it.key !== currentKey : false).concat({
            type: TYPE_ROUTE,
            key: currentKey
        });
    } else {
        history = getRouteHistory(state.routes, index, backBehavior, initialRouteName);
    }
    return _object_spread_props._(_object_spread._({}, state), {
        index,
        history
    });
};
function TabRouter(ref) {
    var initialRouteName = ref.initialRouteName, _ref_backBehavior = ref.backBehavior, backBehavior = _ref_backBehavior === void 0 ? 'firstRoute' : _ref_backBehavior;
    var router = _object_spread_props._(_object_spread._({}, _BaseRouter.default), {
        type: 'tab',
        getInitialState (ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var index = initialRouteName !== undefined && routeNames.includes(initialRouteName) ? routeNames.indexOf(initialRouteName) : 0;
            var routes = routeNames.map((name)=>({
                    name,
                    key: `${name}-${(0, _nonsecure.nanoid)()}`,
                    params: routeParamList[name]
                }));
            var history = getRouteHistory(routes, index, backBehavior, initialRouteName);
            return {
                stale: false,
                type: 'tab',
                key: `tab-${(0, _nonsecure.nanoid)()}`,
                index,
                routeNames,
                history,
                routes
            };
        },
        getRehydratedState (partialState, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var _state_routes_, _state_history;
            var state = partialState;
            if (state.stale === false) {
                return state;
            }
            var routes = routeNames.map((name)=>{
                var route = state.routes.find((r)=>r.name === name);
                return _object_spread_props._(_object_spread._({}, route), {
                    name,
                    key: route && route.name === name && route.key ? route.key : `${name}-${(0, _nonsecure.nanoid)()}`,
                    params: routeParamList[name] !== undefined ? _object_spread._({}, routeParamList[name], route ? route.params : undefined) : route ? route.params : undefined
                });
            });
            var index = Math.min(Math.max(routeNames.indexOf((_state_routes_ = state.routes[(state === null || state === void 0 ? void 0 : state.index) ?? 0]) === null || _state_routes_ === void 0 ? void 0 : _state_routes_.name), 0), routes.length - 1);
            var history = ((_state_history = state.history) === null || _state_history === void 0 ? void 0 : _state_history.filter((it)=>routes.find((r)=>r.key === it.key))) ?? [];
            return changeIndex({
                stale: false,
                type: 'tab',
                key: `tab-${(0, _nonsecure.nanoid)()}`,
                index,
                routeNames,
                history,
                routes
            }, index, backBehavior, initialRouteName);
        },
        getStateForRouteNamesChange (state, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeKeyChanges = ref.routeKeyChanges;
            var routes = routeNames.map((name)=>state.routes.find((r)=>r.name === name && !routeKeyChanges.includes(r.name)) || {
                    name,
                    key: `${name}-${(0, _nonsecure.nanoid)()}`,
                    params: routeParamList[name]
                });
            var index = Math.max(0, routeNames.indexOf(state.routes[state.index].name));
            var history = state.history.filter(// Type will always be 'route' for tabs, but could be different in a router extending this (e.g. drawer)
            (it)=>it.type !== 'route' || routes.find((r)=>r.key === it.key));
            if (!history.length) {
                history = getRouteHistory(routes, index, backBehavior, initialRouteName);
            }
            return _object_spread_props._(_object_spread._({}, state), {
                history,
                routeNames,
                routes,
                index
            });
        },
        getStateForRouteFocus (state, key) {
            var index = state.routes.findIndex((r)=>r.key === key);
            if (index === -1 || index === state.index) {
                return state;
            }
            return changeIndex(state, index, backBehavior, initialRouteName);
        },
        getStateForAction (state, action, ref) {
            var routeParamList = ref.routeParamList, routeGetIdList = ref.routeGetIdList;
            switch(action.type){
                case 'JUMP_TO':
                case 'NAVIGATE':
                    {
                        var index = -1;
                        if (action.type === 'NAVIGATE' && action.payload.key) {
                            index = state.routes.findIndex((route)=>route.key === action.payload.key);
                        } else {
                            index = state.routes.findIndex((route)=>route.name === action.payload.name);
                        }
                        if (index === -1) {
                            return null;
                        }
                        return changeIndex(_object_spread_props._(_object_spread._({}, state), {
                            routes: state.routes.map((route, i)=>{
                                if (i !== index) {
                                    return route;
                                }
                                var getId = routeGetIdList[route.name];
                                var currentId = getId === null || getId === void 0 ? void 0 : getId({
                                    params: route.params
                                });
                                var nextId = getId === null || getId === void 0 ? void 0 : getId({
                                    params: action.payload.params
                                });
                                var key = currentId === nextId ? route.key : `${route.name}-${(0, _nonsecure.nanoid)()}`;
                                var params;
                                if (action.type === 'NAVIGATE' && action.payload.merge && currentId === nextId) {
                                    params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], route.params, action.payload.params) : route.params;
                                } else {
                                    params = routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], action.payload.params) : action.payload.params;
                                }
                                var path = action.type === 'NAVIGATE' && action.payload.path != null ? action.payload.path : route.path;
                                return params !== route.params || path !== route.path ? _object_spread_props._(_object_spread._({}, route), {
                                    key,
                                    path,
                                    params
                                }) : route;
                            })
                        }), index, backBehavior, initialRouteName);
                    }
                case 'GO_BACK':
                    {
                        if (state.history.length === 1) {
                            return null;
                        }
                        var previousKey = state.history[state.history.length - 2].key;
                        var index1 = state.routes.findIndex((route)=>route.key === previousKey);
                        if (index1 === -1) {
                            return null;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            history: state.history.slice(0, -1),
                            index: index1
                        });
                    }
                default:
                    return _BaseRouter.default.getStateForAction(state, action);
            }
        },
        shouldActionChangeFocus (action) {
            return action.type === 'NAVIGATE';
        },
        actionCreators: TabActions
    });
    return router;
}


}),
76951: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get BaseRouter () {
        return _BaseRouter.default;
    },
    get CommonActions () {
        return _CommonActions;
    },
    get DrawerActions () {
        return _DrawerRouter.DrawerActions;
    },
    get DrawerRouter () {
        return _DrawerRouter.default;
    },
    get StackActions () {
        return _StackRouter.StackActions;
    },
    get StackRouter () {
        return _StackRouter.default;
    },
    get TabActions () {
        return _TabRouter.TabActions;
    },
    get TabRouter () {
        return _TabRouter.default;
    }
});
var _export_star = __webpack_require__(80010);
var _interop_require_default = __webpack_require__(92766);
var _interop_require_wildcard = __webpack_require__(97427);
var _CommonActions = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(60106));
var _BaseRouter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8101));
var _DrawerRouter = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(36127));
var _StackRouter = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(32734));
var _TabRouter = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(16449));
_export_star._(__webpack_require__(33623), exports);


}),
33623: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));


}),

}]);//# sourceMappingURL=vendors-node_modules_react-navigation_native_src_index_tsx.chunk.bundle.map?platform=ios